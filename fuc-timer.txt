Introduction

Time and timer-related registers are the same across each fuc engines.

You can:

 - Read PTIMER's clock
 - Use a periodic timer: Generate an interrupt periodically
 - Use a watchdog/one-shot timer: Generate an interrupt once in the future


Time-related registers overview

As seen in [fuc-io.txt], these registers can be accessed both from
host (using MMIO areas in BAR0) and fuc (using io* instructions).
The addresses of the relevant registers are detailed bellow.

host/I[] address / name / file

Common registers:
020/00800  PERIODIC_PERIOD	periodic timer period
024/00900  PERIODIC_TIME	periodic timer counter
028/00a00  PERIODIC_ENABLE	periodic interrupt en
02c/00b00  TIME_LOW		PTIMER time low
030/00c00  TIME_HIGH		PTIMER time high
034/00d00  WATCHDOG_TIME	watchdog timer counter
038/00e00  WATCHDOG_ENABLE	watchdog interrupt en


Reading PTIMER's clock

PTIMER's clock is a 64 bits value that is spread on two registers:

- TIME_LOW: The lower part of PTIMER's clock
- TIME_HIGH: The higher part of PTIMER's clock

In order to accurately read the clock, the following code should be used:

uint32 high1, high2, low;

do
{
	high1 = iord(TIME_HIGH);
	low = iord(TIME_LOW);
	high2 = iord(TIME_HIGH);
} while(high1 != high2);

This code works the mutual dependency. Without it, there could be some reading
errors of 32 bits:

 - TIME_LOW is read, overflows and then TIME_HIGH is read
 - TIME_HIGH is read, TIME_LOW overflows, TIME_LOW is read

MMIO 0x020 / I[0x00800]: PERIODIC_PERIOD
MMIO 0x024 / I[0x00900]: PERIODIC_TIME
MMIO 0x028 / I[0x00a00]: PERIODIC_ENABLE

Fuc engines all have a periodic timer. This timer generates an interrupt
periodically on the line 0.

More technically, this happens when PERIODIC_TIME reaches 0. This register
is decremented after each PTIMER's tick unless PERIODIC_ENABLE is clear.

The periodicity can be setup by setting the PERIODIC_PERIOD register to the number
of PTIMER ticks wanted.

Operation (after each PTIMER tick):
	if (iord(PERIODIC_ENABLE)
		iowr(PERIODIC_TIME, iord(PERIODIC_TIME) - 1);

	if (iord(PERIODIC_TIME) == 0) {
		iowr(INTR_SET, 0b1)
		iowr(PERIODIC_TIME, iord(PERIODIC_PERIOD));
	}

MMIO 0x034 / I[0x00d00]: WATCHDOG_TIME
MMIO 0x038 / I[0x00e00]: WATCHDOG_ENABLE

A watchdog is usually a timer that, when reaching 0, resets a microcontroler.
This is a mean of rebooting a microcontroler when it is stuck in an infinite loop.

A classic use of a watchdog is to set it before calling a sensitive function by
initializing it to, for instance, twice the usual time needed by this function to
be executed.

In fuc's case, the watchdog doesn't reboot the Âµc.
It is very similar to the periodic timer. The differences are:

 - it generates an interrupt on line 1 instead of 0. 
 - it manually needs to be reset

Operation (after each PTIMER tick):
	if (iord(WATCHDOG_ENABLE)
		iowr(WATCHDOG_TIME, iord(WATCHDOG_TIME) - 1);

	if (iord(WATCHDOG_TIME) == 0)
		iowr(INTR_SET, 0b10)
