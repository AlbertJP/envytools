#!/usr/bin/perl -sw
#RE tool, decodes hex into bitfield descriptions {pos,len}
#   supports disjoint bitfields
#   supports 64 and 32 bit hex (in envydis's endianness)
#   modes: and, or, xor (mask, diff)
#Examples:
#   find a diff between to OPs:
#       ./bftool -op=xor 8540dc00001c0002 8540dc00001c3c02 
#           U8{0x0000000000003c00} U4{0x00003c00,0x00000000}
#           10,4
#   the same, but with 32bit input:
#       ./bftool -op=xor 001c0002 8540dc00 001c3c02 8540dc00
#           U8{0x0000000000003c00} U4{0x00003c00,0x00000000}
#           10,4
#   find a match against a mask:
#       ./bftool -op=and 3fc0000000000000 8540dc00001c0002
#           U8{0x0540000000000000} U4{0x00000000,0x05400000}
#           54,1
#           56,1
#           58,1
no warnings "portable";
my $op = $op || "nop";
my $n = scalar(@ARGV);
my $x = 0;
my $y = 0;
die "bad arg count" if not ($n==1 or $n==2 or $n==4);
if($op eq "nop"){
	die "bad arg count" if $n>2;
	$x = hex($ARGV[0]);
	$x = $x | hex($ARGV[1]) << 32 if($n==2);
}
else{
	if($n==2){
		$x = hex($ARGV[0]);
		$y = hex($ARGV[1]);
	}
	elsif($n==4){
		$x = hex($ARGV[1]) << 32 | hex($ARGV[0]);
		$y = hex($ARGV[3]) << 32 | hex($ARGV[2]);
	}
}
if($op eq "and"){
	$x = $x & $y;
}
elsif($op eq "xor"){
	$x = $x ^ $y;
}
elsif($op eq "or"){
	$x = $x | $y;
}
print sprintf("U8{0x%016x} U4{0x%08x,0x%08x}\n",$x,$x&0xFFFFFFFF,($x>>32)&0xFFFFFFFF);
my $pos=0;
while($x!=0){
	while(($x&0x1) eq 0){
		$pos++;
		$x = $x >> 1;
	}
	my $len=0;
	while(($x&0x1) eq 1){
		$len++;
		$x = $x >> 1;
	}
	print $pos,",",$len,"\n";
    $pos+=$len;
}
