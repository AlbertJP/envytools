TOC

0. Intruduction
1. The opcode format
2. Special registers
3. Instruction reference


= Introduction =

This file deals with description of the ISA used by the vµc microprocessor,
which is described in vuc.txt.

The microprocessor registers, instructions and memory spaces are mostly 16-bit
oriented. There are 3 ISA register files:

 - $r0-$r15, 16-bit general-purpose registers, for arithmetic and addressing
   - $r0: read-only and hardwired to 0
   - $r1-$r15: read/write
 - $p0-$p15, 1-bit predicate registers, for conditional execution
   - $p0: read/write
   - $p1: read only and hardwired to !$p0
   - $p2-$p14: read/write
   - $p15: read-only and hardwired to 1
 - $sr0-$sr63, 16-bit special registers - see below for a list

There are 7 address spaces the vµc can access:
 - D[] - user data, word-addressed, 0x800 16-bit words long, loads and stores
         are in word units.
 - PWT[] - pred weight table data, read-only. This space is filled when
           a packet of type 4 is read from the MBRING. Byte-addressed, 0x200
	   bytes long, loads are in byte units.
 - VP[] - VPRING output data, write-only. Data stored here will be written to
          VPRING_DEBLOCK and VPRING_CTRL when corresponding commands are
	  invoked. Byte-addressed, 0x400 bytes long. Stores are in byte or
	  word units depending on the address.
 - MVSI[] - MVSURF input data, read-only. Filled with data from the input
            MVSURF when mvsread opcode is executed. Word-addressed, 0x100
	    words long, loads are in word units.
 - MVSO[] - MVSURF output data, write-only. Data stored here will be written
            to the output MVSURF when mvswrite opcode is executed.
	    Word-addressed, 0x80 words long, stores are in word units.
 - B6[] - io address space? [XXX]
 - B7[] - io address space? [XXX]

The vµc code resides in the code space, separate from the above spaces. The
code space is a dedicated SRAM of 0x800 instruction words. An instruction word
consists of 40 bits on VP2, 30 bits on VP3.


= The delays =

The vµc lacks interlocks - on every cycle when vµc microcprocessor is active
and not sleeping/waiting, one instruction begins execution. Most instructions
finish in one cycle. However, when an instruction takes more than one cycle to
finish, vµc will continue to fetch and execute subsequent instructions even
if they have dependencies on the current instruction - it is thus required to
manually insert nops in the code or schedule instructions to avoid such
situations.

An X-cycle instruction happens in three phases:
 - cycle 0: source read - the inputs to the instruction are gathered
 - cycles 0..(X-1): result computation -
 - cycle X: destination writeout - the results are stored into the destination
   registers

For example, add $r1 $r2 $r3 is a 1-cycle instruction. On cycle 0, the sources
are read and the result is computed. On cycle 1, in parallel with executing
the next instruction, the result is written out to $r1.

The extra cycle for destination writeout means that, in general, it's required
to have at least 1 unrelated instruction between writing a register and reading
it. However, vµc implements store-to-load forwarding for some common cases -
the result value, which is already known on cycle (X-1), is transferred
directly into the next instruction, if there's a match betwen the next
instruction's source register index and current instruction's destination
register index. Store-to-load forwarding happens in the following situations:

 - all $r register reads and writes
 - all $p register reads and writes, except by accessing them through $pred
   special register
 - $lhi/$llo register reads and writes done implicitely by long arithmetic
   instructions

Store-to-load forwarding does NOT happen in the following situations:

 - $sr register reads and writes

Example 1:
	add $r1 $r2 $r3
	add $r4 $r1 $r5
	no delay needed, store-to-load forwarding happens:
	cycle 0: $r2 and $r3 read, $r2+$r3 computed
	cycle 1: $r5 read, previous result read due to l-t-s forwarding match
		 for $r1, prev+$r5 computed, previous result written to $r1
	cycle 2: next instruction begins execution, insn 1 result written to
		 $r5

Example 2 [missing delay]:
	add $mvxl0 $r2 $r3
	add $r4 $mvxl0 $r5
	delay needed, but not supplied - store-to-load forwarding doesn't
	happen and old value is read:
	cycle 0: $r2 and $r3 read, $r2+$r3 computed
	cycle 1: $mvxl0 and $r5 read, $mvxl0+$r5 computed, previous result
		 written to $mvxl0
	cycle 2: next instruction begins execution, insn 1 result written to
		 $r5
	Code is equivalent to:
		$r4 = $mvxl0 + $r5;
		$mvxl0 = $r2 + $r3;

Example 3 [proper delay]:
	add $mvxl0 $r2 $r3
	nop
	add $r4 $mvxl0 $r5
	delay needed and supplied:
	cycle 0: $r2 and $r3 read, $r2+$r3 computed
	cycle 1: nop executes, previous result written to $mvxl0
	cycle 2: new $mvxl0 and $r5 read, $mvxl0+$r5 computed
	cycle 3: next instruction begins execution, insn 2 result written to
		 $r5
	Code is equivalent to:
		$mvxl0 = $r2 + $r3;
		$r4 = $mvxl0 + $r5;

Since long-running instructions use execution units during their execution,
it's usually forbidden to launch other instructions using the same execution
units until the first instruction is finished. When such execution unit
conflict happens, the old instruction is aborted.

It is possible that two instructions with different write delays will try to
perform a register write in the same cycle (e.g. ld-nop-mov sequence). If the
write destinations are different, both writes will happen as expected. If the
write destinations are the same, destination carries the value of the last
write.

The branch instructions take two cycles to finish - the instruction after the
jump [the delay slot] is executed regardless of whether the jump is taken or
not.


= The opcode format =

The opcode bits are:

 0-4: opcode selection [OP]
 5-6, base opcodes: predicate output mode [POM]
   00: $p &= predicate output
   01: $p |= predicate output
   10: $p = predicate output
   11: predicate output discarded
 7, base opcodes: predicate output negation flag [PON]
 5-7, special opcodes: special opcode class selection [OC]
   000: control flow
   001: io control
   010: predicate manipulation
   100: load/store
   101: multiplication
 8-11: source 1 [SRC1]
 12-15: source 2 [SRC2]
 16-19: destionation [DST]
 8-18: branch target [BTARG]
 20-23: predicate [PRED]
 24-25: extra bits for immediate and $sr [EXT]
 26: opcode type 0 [OT0]
 27: source 2 immediate flag [IMMF]
 28: opcode type 1 [OT1]
 29: predicate enable flag [PE]
 30-32: relative branch predicate [RBP] - VP2 only
 33: relative branch predicate negation flag [RBN] - VP2 only
 34-39: relative branch target [RBT] - VP2 only

On VP2, a single instruction word holds two instruction slots - the normal
instruction slot in bits 0-29, and the relative branch instruction slot in
bits 30-39. When the instruction is executed, both instruction slots are
executed simultanously and independently.

The relative branch slot can hold only one type of instruction, which is the
relative branch. The main slot can hold all other types of instructions.
It's possible to encode two different jumps in one opcode by utilising both the
branch slot and the main instruction slot for a branch. The branch will take
place if any of the two branch conditions match. If both branch conditions
match, the actual branch executed is the one in the main slot.

On VP3+, the relative branch slot no longer exists, and the main slot makes up
the whole instruction word.

There are two major types of opcodes that can be stored in the main slot: base
opcodes and special opcodes. The type of instruction in the main slot is
determined by OT0 and OT1 bits:

 - OT0 = 0, OT1 = 0: base opcode, $r destination, $r source 1
 - OT0 = 1, OT1 = 0: base opcode, $r destination, $sr source 1
 - OT0 = 0, OT1 = 1: base opcode, $sr destination, $r source 1
 - OT0 = 1, OT1 = 1: special opcode

For base opcodes, the OP bits determine the final opcode:

 - 00000: slct		[slct form]	select
 - 00001: mov		[mov form]	move
 - 00100: add		[binary form]	add
 - 00101: sub 		[binary form]	substract
 - 00110: subr 		[binary form] 	substract reverse	[VP2 only]
 - 00110: avgs 		[binary form] 	average signed		[VP3+ only]
 - 00111: avgu 		[binary form] 	average unsigned	[VP3+ only]
 - 01000: setgt 	[set form]	set if greater than
 - 01001: setlt 	[set form]	set if less than
 - 01010: seteq 	[set form]	set if equal to
 - 01011: setlep 	[set form]	set if less or equal and positive
 - 01100: clamplep 	[binary form]	clamp to less or equal and positive
 - 01101: clamps 	[binary form]	clamp signed
 - 01110: sext 		[binary form]	sign extension
 - 01111: setzero 	[set form] 	set if both zero	[VP2 only]
 - 01111: div2s 	[unary form]	divide by 2 signed	[VP3+ only]
 - 10000: bset 		[binary form]	bit set
 - 10001: bclr 		[binary form]	bit clear
 - 10010: btest 	[set form]	bit test
 - 10100: hswap		[unary form]	swap reg halves
 - 10101: shl 		[binary form]	shift left
 - 10110: shr 		[binary form]	shift right
 - 10111: sar 		[binary form]	shift arithmetic right
 - 11000: and 		[binary form]	bitwise and
 - 11001: or 		[binary form]	bitwise or
 - 11010: xor 		[binary form]	bitwise xor
 - 11011: not		[unary form]	bitwise not
 - 11100: lut 		[binary form]	video LUT lookup
 - 11101: min 		[binary form] 	minimum			[VP3+ only]
 - 11110: max 		[binary form] 	maximum			[VP3+ only]

For special opcodes, the OC bits determine the opcode class, and OP bits
further determine the opcode inside that class. The classes and opcodes are:

 - OC 000: control flow
  - 00000: bra		[branch form]		branch
  - 00010: call		[branch form]		call
  - 00011: ret		[simple form]		return
  - 00100: sleep	[simple form]		sleep
  - 00101: wstc		[immediate form]	wait for status bit clear
  - 00110: ??? [XXX]	[immediate form]
 - OC 001: io control
  - 00000: clicnt	[simple form]		clear instruction counter
  - 00001: ??? [XXX]	[simple form]
  - 00010: ??? [XXX]	[simple form]
  - 00011: ??? [XXX]	[simple form]
  - 00100: mbiread	[simple form]		macroblock input read
  - 00101: ??? [XXX]	[simple form]
  - 00110: ??? [XXX]	[simple form]
  - 01000: mbinext	[simple form]		macroblock input next
  - 01001: mvsread	[simple form]		MVSURF read
  - 01010: mvswrite	[simple form]		MVSURF write
  - 01011: ??? [XXX]	[simple form]
  - 01100: ??? [XXX]	[simple form]
 - OC 010: predicate manipulation
  - xxx00: and		[predicate form]	and
  - xxx01: or		[predicate form]	or
  - xxx10: xor		[predicate form]	xor
  - xxx11: nop		[simple form]		no operation
 - OC 100: load/store
  - xxxx0: st		[store form]		store
  - xxxx1: ld		[load form]		load
 - OC 101: long arithmetic
  - 00000: lmulu	[long binary form]	long multiply unsigned
  - 00001: lmuls	[long binary form]	long multiply signed
  - 00010: lsrr		[long unary form]	long shift right with round
  - 00100: ladd		[long unary form]	long add			[VP3+ only]
  - 01000: lsar		[long unary form]	long shift right arithmetic	[VP3+ only]
  - 01100: ldivu	[long unary form]	long divide unsigned		[VP4 only]

All main slot opcodes can be predicated by an arbitrary $p register. The PE
bit enables predication. If PE bit is 1, the main slot instruction will only
have an effect if the $p register selected by PRED field has value 1. Note
that PE bit also has an effect on instruction format - longer immediates are
allowed, and the predicate destination field changes.

Note that, for some formats, opcode fields may be used for multiple purposes.
For example, mov instruction with PE=1 and IMMF=1 uses PRED bitfield both as
the predicate selector and as the middle part of the immediate operand. Such
formats should be avoided unless it can be somehow guaranteed that the value
in the field will fit all purposes it's used for.

The base opcodes have the following operands:

 - binary form:	pdst, dst, src1, src2
 - unary form:	pdst, dst, src1
 - set form:	pdst, src1, src2
 - slct form:	pdst, dst, pred, src1, src2
 - mov form:	pdst, dst, lsrc

The operands and their encodings are:
 - pdst: predicate destination - this operand is special, as it can be used
   in several modes. First, the instruction generates a boolean predicate
   result. Then, if PON bit is set, this output is negated. Finally, it is
   stored to a $p register in one of 4 modes:
   - POM = 00: $p &= output
   - POM = 01: $p |= output
   - POM = 10: $p = output
   - POM = 11: output is discarded
   The $p output register is:
   - PE = 0: $p register selected by PRED field
   - PE = 1: $p register selected by DST field
 - dst: main destination
   - OT0 = 1 or OT1 = 0: $r register selected by DST field
   - OT0 = 0 and OT1 = 1: $sr register selected by DST [low bits] and EXT
     [high bits] fields
 - pred - predicate source
   - all cases: $p register selected by PRED field
 - src1: first source
   - OT0 = 0 or OT1 = 1: $r register selected by SRC1 field,
   - OT0 = 1 and OT1 = 0: $sr register selected by SRC1 [low bits] and EXT
     [high bits] fields.
 - src2: second source
   - IMMF = 0: $r register selected by SRC2 field
   - IMMF = 1 and OT0 = OT1:. zero-extended 6-bit immediate value stored in
     SRC2 [low bits] and EXT [high bits] fields.
   - IMMF = 1 and OT0 != OT1: zero-extended 4-bit immediate value stored in
     SRC2 field.
 - lsrc: long source
   - IMMF = 0: $r register selected by SRC2 field
   - IMMF = 1 and OT1 = 0:. zero-extended 14-bit immediate value stored in
     SRC1 [low bits], SRC2 [low middle bits], PRED [high middle bits] and EXT
     [high bits] fields.
   - IMMF = 1 and OT1 = 1:. zero-extended 12-bit immediate value stored in
     SRC1 [low bits], SRC2 [middle bits] and PRED [high bits] fields

The special opcodes have the following operands:
 - simple form:		[none]
 - immediate form:	imm4 [XXX]
 - branch form:		btarg [XXX]
 - predicate form:	spdst, psrc1, psrc2
 - store form:		space[src1 + stoff], src2	[XXX: wrong for non-D[]]
 - load form:		dst, space[src1 + ldoff]	[XXX: wrong for non-D[]]
 - long binary form:	src1, src2
 - long unary form:	src2

The operands and their encodings are:
 - src1, src2, dst: like for base opcodes
 - imm4: 4-bit immediate
   - all cases: 4-bit immediate stored in SRC2 field [XXX]
 - btarg: code address
   - all cases: 11-bit immediate stored in BTARG field
 - spdst: predicate destination
   - PE = 0: $p register selected by PRED field
   - PE = 1: $p register selected by DST field
 - psrc1: predicate source 1, optionally negated
   - all cases: $p register selected by SRC1 field, negated if bit 3 of OP
     field is set
 - psrc2: predicate source 2, optionally negated
   - all cases: $p register selected by SRC2 field, negated if bit 2 of OP
     field is set
 - space: memory space selection, OP field bits 1-4:
   - 0000: D[]
   - 0001: PWT[] - ld only
   - 0010: VP[] - st only
   - 0100: MVSI[] - ld only
   - 0101: MVSO[] - st only
   - 0110: B6[]
   - 0111: B7[]
 - stoff: store offset
   - IMMF = 0: $r register selected by DST field
   - IMMF = 1, PE = 0: 10-bit zero-extended immediate stored in DST [low
     bits], PRED [middle bits] and EXT [high bits] fields
   - IMMF = 1, PE = 1: 6-bit zero-extended immediate stored in DST [low
     bits] and EXT [high bits] fields
 - ldoff: load offset
   - IMMF = 0: $r register selected by SRC2 field
   - IMMF = 1, PE = 0: 10-bit zero-extended immediate stored in SRC2 [low
     bits], PRED [middle bits] and EXT [high bits] fields
   - IMMF = 1, PE = 1: 6-bit zero-extended immediate stored in SRC2 [low
     bits] and EXT [high bits] fields


= Special register list =

[XXX: the following information may only be valid for H.264 mode for now]
 - $sr0: ??? controls $sr48-$sr58 (bits 0-6 when set separately) [XXX] [VP2
   only]
 - $sr1: ??? similar to $sr0 (bits 0-4, probably more) [XXX] [VP2 only]
 - $sr2/$spidx: partition and subpartition index, used to select which
   [sub]partitions some other special registers access:
     bits 0-1: subpartition index
     bits 2-3: partition index
     Note that, for indexing purposes, each partition index is considered
     to refer to an 8x8 block, and each subpartition index to 4x4 block. If
     partition/subpartition size is bigger than that, the indices will
     alias. Thus, for 16x8 partitioning mode, $spidx equal to 0-7 wil select
     the top partition, $spidx equal to 8-15 will select the bottom one. For
     8x16 partitioning, $spidx equal to 0-3 and 8-11 will select the left
     partition, 4-7 and 12-15 will select the right partition.
 - $sr3: ??? bits 0-4 affect $sr32-$sr42 [XXX] [VP2 only]
 - $sr3: ??? [XXX] [VP3+ only]
 - $sr4/$h2v: a scratch register to pass data from host to vµc [see vuc.txt]
 - $sr5/$v2h: a scratch register to pass data from vµc to host [see vuc.txt]
 - $sr6/$stat: some sort of control/status reg, writing 0x8000 alternates
   values between 0x8103 and 0 [XXX]
     bit 0: ??? [XXX]
     bit 1: ??? [XXX]
     bit 2: ??? [XXX]
     bit 3: ??? [XXX]
     bit 8: ??? [XXX]
     bit 10: macroblock input available - set whenever there's a complete
       macroblock available from MBRING, cleared when mbinext instruction
	 skips past the last currently available macroblock. Will break out
	 of sleep instruction when set.
     bit 11: $h2v modified - set when host writes H2V, cleared when $h2v
       is read by vµc, will break out of sleep instruction when set.
     bit 12: watchdog hit - set 1 cycle after $icnt reaches WDCNT and it's
       not equal to 0xffff, cleared when $icnt or WDCNT is modified in any
	 way.
     bit 15: ??? [XXX]
 - $sr7/$parm: sequence/picture/slice parameters required by vµc hardware
   [see vuc.txt]
 - $sr8/$pc: address of currently executed instruction
 - $sr9/$cspos: call stack position, 0-8. Equal to the number of used entries
   on the stack.
 - $sr10/$cstop: call stack top. Writing to this register causes the written
   value to be pushed onto the stack, reading this register pops a value off
   the stack and returns it.
 - $sr11/$rpitab: D[] address of refidx -> dpb index translation table [VP2
   only]
 - $sr12/$lhi: long arithmetic high word register - RO on VP2, RW on VP3+
 - $sr13/$llo: long arithmetic low word register - RO on VP2, RW on VP3+
 - $sr14/$pred: predicates - aliases the $p register file, bit X corresponds
   to $pX register
 - $sr15/$icnt: instruction/cycle counter (?: check nops, effect of delays)
 - $sr16/$mvxl0: sign-extended mvd_l0[$spidx][0] [input]
 - $sr17/$mvyl0: sign-extended mvd_l0[$spidx][1] [input]
 - $sr18/$mvxl1: sign-extended mvd_l1[$spidx][0] [input]
 - $sr19/$mvyl1: sign-extended mvd_l1[$spidx][1] [input]
 - $sr20/$refl0: ref_idx_l0[$spidx>>2] [input]
 - $sr21/$refl1: ref_idx_l1[$spidx>>2] [input]
 - $sr22/$rpil0: dpb index of L0 reference picture for $spidx-selected
   partition
 - $sr23/$rpil1: dpb index of L1 reference picture for $spidx-selected
   partition
 - $sr24/$mbflags:
     bit 0: mb_field_decoding_flag [RW]
     bit 1: is intra macroblock [RO]
     bit 2: is I_NxN macroblock [RO]
     bit 3: transform_size_8x8_flag [RW]
     bit 4: ??? [XXX]
     bit 5: is I_16x16 macroblock [RO]
     bit 6: partition selected by $spidx uses L0 or Bi prediction [RO]
     bit 7: partition selected by $spidx uses L1 or Bi prediction [RO]
     bit 8: mb_field_decoding_flag for next macroblock [only valid if $sr6
            bit 10 is set] [RO]
     bit 9: mb_skip_flag for next macroblock [only valid if $sr6 bit 10 is
            set] [RO]
     bit 10: partition selected by $spidx uses Direct prediction [RO]
     bit 11: any partition of macroblock uses Direct prediction [RO]
     bit 12: is I_PCM macroblock [RO]
     bit 13: is P_SKIP macroblock [RO]
 - $sr25/$qpy:
     bits 0-5: mb_qp_delta [input] / QPy [output] [H.264]
     bits 0-5: quantiser_scale_code [input and output] [MPEG1/MPEG2]
     bits 8-11: intra_chroma_pred_mode, values:
       0: DC [input], DC_??? [output] [XXX]
	 1: horizontal [input, output]
	 2: vertical [input, output]
	 3: plane [input, output]
	 4: DC_??? [output]
	 5: DC_??? [output]
	 6: DC_??? [output]
	 7: DC_??? [output]
	 8: DC_??? [output]
	 9: DC_??? [output]
	 0xa: DC_??? [output]
 - $sr26/$qpc:
     bits 0-5: QPc for Cb [output] [H.264]
     bits 8-13: QPc for Cr [output] [H.264]
 - $sr27/$mbpart:
     bits 0-1: macroblock partitioning type
       0: 16x16
       1: 16x8
       2: 8x16
       3: 8x8
     bits 2-3: partition 0 subpartitioning type
     bits 4-5: partition 0 subpartitioning type
     bits 6-7: partition 0 subpartitioning type
     bits 8-9: partition 0 subpartitioning type
       0: 8x8
       1: 8x4
       2: 4x8
       3: 4x4
 - $sr28/$mbxy:
     bits 0-7: macroblock Y position
     bits 8-15: macroblock X position
 - $sr29/$mbaddr:
     bits 0-12: macroblock address
     bit 15: first macroblock in slice flag
 - $sr30/$mbtype: macroblock type, for H.264:
     0x00: I_NxN
     0x01: I_16x16_0_0_0
     0x02: I_16x16_1_0_0
     0x03: I_16x16_2_0_0
     0x04: I_16x16_3_0_0
     0x05: I_16x16_0_1_0
     0x06: I_16x16_1_1_0
     0x07: I_16x16_2_1_0
     0x08: I_16x16_3_1_0
     0x09: I_16x16_0_2_0
     0x0a: I_16x16_1_2_0
     0x0b: I_16x16_2_2_0
     0x0c: I_16x16_3_2_0
     0x0d: I_16x16_0_0_1
     0x0e: I_16x16_1_0_1
     0x0f: I_16x16_2_0_1
     0x10: I_16x16_3_0_1
     0x11: I_16x16_0_1_1
     0x12: I_16x16_1_1_1
     0x13: I_16x16_2_1_1
     0x14: I_16x16_3_1_1
     0x15: I_16x16_0_2_1
     0x16: I_16x16_1_2_1
     0x17: I_16x16_2_2_1
     0x18: I_16x16_3_2_1
     0x19: I_PCM
     0x20: P_L0_16x16
     0x21: P_L0_L0_16x8
     0x22: P_L0_L0_8x16
     0x23: P_8x8
     0x24: P_8x8ref0
     0x40: B_Direct_16x16
     0x41: B_L0_16x16
     0x42: B_L1_16x16
     0x43: B_Bi_16x16
     0x44: B_L0_L0_16x8
     0x45: B_L0_L0_8x16
     0x46: B_L1_L1_16x8
     0x47: B_L1_L1_8x16
     0x48: B_L0_L1_16x8
     0x49: B_L0_L1_8x16
     0x4a: B_L1_L0_16x8
     0x4b: B_L1_L0_8x16
     0x4c: B_L0_Bi_16x8
     0x4d: B_L0_Bi_8x16
     0x4e: B_L1_Bi_16x8
     0x4f: B_L1_Bi_8x16
     0x50: B_Bi_L0_16x8
     0x51: B_Bi_L0_8x16
     0x52: B_Bi_L1_16x8
     0x53: B_Bi_L1_8x16
     0x54: B_Bi_Bi_16x8
     0x55: B_Bi_Bi_8x16
     0x56: B_8x8
     0x7e: B_SKIP
     0x7f: P_SKIP
 - $sr31/$submbtype: [VP2 only]
     bits 0-3: sub_mb_type[0]
     bits 4-7: sub_mb_type[1]
     bits 8-11: sub_mb_type[2]
     bits 12-15: sub_mb_type[3]
 - $sr31: ??? [XXX] [VP3+ only]
 - $sr32-$sr40: ??? affected by $sr3, unko21, read only [XXX]
 - $sr41-$sr42: ??? affected by $sr3, unko21, read only [XXX] [VP2 only]
 - $sr48-$sr58: ??? affected by writing $sr0 and $sr1, unko22, read only [XXX]



XXX: Find signedness of instructions
TODO: Find out exact immediate sizes in most instructions
XXX: Verify remaining delays


= Instructions =

In the pseudocode, all intermediate computation results and temporary
variables are assumed to be infinite-precision signed integers: non-negative
integers are padded at the left with infinite number of 0 bits, while negative
integers are padded with infinite number of 1 bits.

When assigning a result to a finite-precision register, any extra bits are
chopped off. When reading a value from a finite-precision register, it's
padded with infinite number of 0 bits at the left by default. A sign-extension
read, where the register value is padded with infinite number of copies of its
MSB instead, is written as SEX(reg).

Operators used in the pseudocode behave as in C.


== Data movement instructions: slct, mov ==

mov sets the destination to the value of the only source. slct sets the
destination to the value of one of the sources, as selected by a predicate.

Instruction: slct pdst, dst, pred, src1, src2
Opcode: base opcode, OP = 00000
Operation:
	result = (pred ? src1 : src2);
	dst = result;
	pdst = result & 1;
Execution time: 1 cycle
Predicate output: LSB of normal result

Instruction: mov pdst, dst, lsrc
Opcode: base opcode, OP = 00001
Operation:
	result = lsrc;
	dst = result;
	pdst = result & 1;
Execution time: 1 cycle
Predicate output: LSB of normal result


== Addition instructions: add, sub, subr, avgs, avgu ==

add performs an addition of two 16-bit quantities, sub and subr perform
substraction, subr with reversed order of operands. avgs and avgu compute
signed and unsigned average of two sources, rounding up. If predicate output
is used, the predicate is set to the lowest bit of the result.

Instructions:
	add pdst, dst, src1, src2	OP=00100
	sub pdst, dst, src1, src2	OP=00101
	subr pdst, dst, src1, src2	OP=00110 [VP2 only]
	avgs pdst, dst, src1, src2	OP=00110 [VP3+ only]
	avgu pdst, dst, src1, src2	OP=00111 [VP3+ only]
Opcode: base opcode, OP as above
Operation:
	if (op == add) result = src1 + src2;
	if (op == sub) result = src1 - src2;
	if (op == subr) result = src2 - src1;
	if (op == avgs) result = (SEX(src1) + SEX(src2) + 1) >> 1;
	if (op == avgu) result = (src1 + src2 + 1) >> 1;
	dst = result;
	pdst = result & 1;
Execution time: 1 cycle
Predicate output: LSB of normal result


== Comparison instructions: setgt, setlt, seteq, setlep, setzero ==

setgt, setlt, seteq perform signed >, <, == comparison on two source operands
and return the result as pdst. setlep returns 1 if src1 is in range [0, src2].
All comparisons are signed 16-bit. setzero returns 1 if both src1 and src2 are
equal to 0.

Instructions:
	setgt pdst, src1, src2		OP=01000
	setlt pdst, src1, src2		OP=01001
	seteq pdst, src1, src2		OP=01010
	setlep pdst, src1, src2		OP=01011
	setzero pdst, src1, src2	OP=01111 [VP2 only]
Opcode: base opcode, OP as above
Operation:
	if (op == setgt) result = SEX(src1) < SEX(src2);
	if (op == setlt) result = SEX(src1) > SEX(src2);
	if (op == seteq) result = src1 == src2;
	if (op == setlep) result = SEX(src1) <= SEX(src2) && SEX(src1) >= 0;
	if (op == setzero) result = src1 == 0 && src2 == 0;
	pdst = result;
Execution time: 1 cycle
Predicate output: the comparison result


== Clamping and sign extension instructions: clamplep, clamps, sext ==

clamplep clamps src1 to [0, src2] range. clamps, like the xtensa instruction
of the same name, clamps src1 to [-(1 << src2), (1 << src2) - 1] range, ie.
to the set of (src2+1)-bit signed integers. sext, like the xteansa and fµc
instructions of the same name, replaces bits src2 and up with a copy of bit
src2, effectively doing a sign extension from a (src2+1)-bit signed number.

Instructions:
	clamplep pdst, dst, src1, src2	OP=01100
	clamps pdst, dst, src1, src2	OP=01101
	sext pdst, dst, src1, src2	OP=01110
Opcode: base opcode, OP as above
Operation:
	if (op == clamplep) {
		result = src1;
		presult = 0;
		if (SEX(src1) < 0) {
			presult = 1;
			result = 0;
		}
		if (SEX(src1) > SEX(src2)) {
			presult = 1;
			result = src2;
		}
	}
	if (op == clamps) {
		bit = src2 & 0xf;
		result = src1;
		presult = 0;
		if (SEX(src1) < -(1 << bit)) {
			result = -(1 << bit);
			presult = 1;
		}
		if (SEX(src1) > (1 << bit) - 1) {
			result = (1 << bit) - 1;
			presult = 1;
		}
	}
	if (op == sext) {
		bit = src2 & 0xf;
		presult = src1 >> bit & 1;
		if (presult)
			result = jrc1 | -(1 << bit);
		else
			result = src1 & ((1 << bit) - 1);
	}
	dst = result;
	pdst = presult;
Execution time: 1 cycle
Predicate output:
	clamplep, clamps: 1 if clamping happened
	sext: 1 if result < 0


== Division by 2 instruction: div2s ==

div2s divides a signed number by 2, rounding to 0.

Instructions:
	div2s pdst, dst, src1		OP=01111 [VP3+ only]
Opcode: base opcode, OP as above
Operation:
	if (SEX(src1) < 0) {
		result = (SEX(src1) + 1) >> 1;
	} else {
		result = src1 >> 1;
	}
	dst = result;
	pdst = result < 0;
Execution time: 1 cycle
Predicate output: 1 if result is negative


== Bit manipulation instructions: bset, bclr, btest ==

bset and bclr set or clear a single bit in a value. btest copies a selected
bit to a $p register.

Instructions:
	bset pdst, dst, src1, src2	OP=10000
	bclr pdst, dst, src1, src2	OP=10001
	btest pdst, src1, src2		OP=10010
Opcode: base opcode, OP as above
Operation:
	bit = src2 & 0xf;
	if (op == bset) {
		result = src1 | 1 << bit;
		presult = result & 1;
		dst = result;
	}
	if (op == bclr) {
		dst = result = src1 & ~(1 << bit)
		presult = result & 1;
		dst = result;
	}
	if (op == btest) {
		presult = src1 >> bit & 1;
	}
	pdst = presult;
Execution time: 1 cycle
Predicate output:
	bset, bclr: bit 0 of the result
	btest: the selected bit


== Swapping reg halves: hswap ==

hswap, like the fµc instruction of the same name, rotates a value by half its
size, which is always 8 bits for vµc.

Instructions:
	hswap pdst, dst, src1		OP=10100
Opcode: base opcode, OP as above
Operation:
	result = src1 >> 8 | src1 << 8;
	dst = result;
	pdst = result & 1;
Execution time: 1 cycle
Predicate output: bit 0 of the result


== Shift instructions: shl, shr, sar ==

shl does a left shift, shr does a logical right shift, sar does an arithmetic
right shift.

Instructions:
	shl pdst, dst, src1, src2	OP=10101
	shr pdst, dst, src1, src2	OP=10110
	sar pdst, dst, src1, src2	OP=10111
Opcode: base opcode, OP as above
Operation:
	shift = src2 & 0xf;
	if (op == shl) {
		result = src1 << shift;
		presult = result >> 16 & 1;
	}
	if (op == shr) {
		result = src1 >> shift;
		if (shift != 0) {
			presult = presult = src1 >> (shift - 1) & 1;
		} else {
			presult = 0;
		}
	}
	if (op == sar) {
		result = SEX(src1) >> shift;
		if (shift != 0) {
			presult = presult = src1 >> (shift - 1) & 1;
		} else {
			presult = 0;
		}
	}
	dst = result;
	pdst = presult;
Execution time: 1 cycle
Predicate output: the last bit shifted out


== Bitwise instructions: and, or, xor, not ==

No comment.

Instructions:
	and pdst, dst, src1, src2	OP=11000
	or pdst, dst, src1, src2	OP=11001
	xor pdst, dst, src1, src2	OP=11010
	not pdst, dst, src1		OP=11011
Opcode: base opcode, OP as above
Operation:
	if (op == and) result = src1 & src2;
	if (op == or) result = src1 | src2;
	if (op == xor) result = src1 ^ src2;
	if (op == not) result = ~src1;
	dst = result;
	pdst = result & 1;
Execution time: 1 cycle
Predicate output: bit 0 of the result


== Table lookup: lut ==

Performs a lookup of src1 in the lookup table selected by low 4 bits of src2.
The tables are codec-specific and generated by hardware from the current
contents of the video special registers.

[XXX: recheck this instruction on VP3 and other codecs]

Tables 0-3 are an alternate way of accessing H.264 inter prediction registers
[$sr16-$sr23]. The table index is 1-bit. Index 0 selects the l0 register,
index 1 selects the l1 register. Table 0 is $mvxl* registers, 1 is $mvyl*, 2
is $refl*, 3 is $rpil*.

Tables 4-7 behave like tables 0-3, except the lookup returns 0 if $mbtype is
equal to 0x7f [P_SKIP].

Table 8, known as pcnt, is used to look up partition and subpartition counts.
The index is 3-bit. Indices 0-3 return the subpartition count of corresponding
partition, while indices 4-7 return the partition count of the macroblock.

Tables 9 and 10 are indexed in a special manner: the index selects a partition
and a subpartition. Bits 0-7 of the index are partition index, bits 8-15 of
the index are subpartition index. The partition and subpartition indices
bahave as in the H.264 spec: valid indices are 0, 0-1, or 0-3 depending on the
partitioning/subpartitioning mode.

Table 9, known as spidx, translates indices of the form given above into
$spidx values. If both partition and subpartition index are valid for the
current partitioning and subpartitioning mode, the value returned is the value
that has to be poked into $spidx to access the selected [sub]partition.
Otherwise, junk may be returned.

Table 10, known as pnext, advances the partition/subpartition index to the
next valid subpartition or partition. The returned value is an index in the
same format as the input index. Additionally, the predicate output is set
if the partition index was not incremented [transition to the next
subpartition of a partition], cleared if the partition index was incremented
[transition to the first subpartition of the next partition].

Table 11, known as pmode, returns the inter prediction mode for a given
partition. The index is 2-bit and selects the partition. If index is less then
pcnt[4] and $mbtype is inter-predicted, returns inter prediction mode,
otherwise returns 0. The prediction modes are:
 0 direct
 1 L0
 2 L1
 3 Bi

Tables 12-15 are unused and always return 0. [XXX: 12 used for VC-1 on VP3]

Instructions:
	lut pdst, dst, src1, src2	OP=11100
Opcode: base opcode, OP as above
Operation:
	/* helper functions */
	int pcnt() {
		switch ($mbtype) {
			case 0:		/* I_NxN */
			case 0x19:	/* I_PCM */
				return 4;
			case 1..0x18:	/* I_16x16_* */
				return 1;
			case 0x20:	/* P_L0_16x16 */
				return 1;
			case 0x21:	/* P_L0_L0_16x8 */
			case 0x22:	/* P_L0_L0_8x16 */
				return 2;
			case 0x23:	/* P_8x8 */
			case 0x24:	/* P_8x8ref0 */
				return 4;
			case 0x40:	/* B_Direct_16x16 */
			case 0x41:	/* B_L0_16x16 */
			case 0x42:	/* B_L1_16x16 */
			case 0x43:	/* B_Bi_16x16 */
				return 1;
			case 0x44:	/* B_L0_L0_16x8 */
			case 0x45:	/* B_L0_L0_8x16 */
			case 0x46:	/* B_L1_L1_16x8 */
			case 0x47:	/* B_L1_L1_8x16 */
			case 0x48:	/* B_L0_L1_16x8 */
			case 0x49:	/* B_L0_L1_8x16 */
			case 0x4a:	/* B_L1_L0_16x8 */
			case 0x4b:	/* B_L1_L0_8x16 */
			case 0x4c:	/* B_L0_Bi_16x8 */
			case 0x4d:	/* B_L0_Bi_8x16 */
			case 0x4e:	/* B_L1_Bi_16x8 */
			case 0x4f:	/* B_L1_Bi_8x16 */
			case 0x50:	/* B_Bi_L0_16x8 */
			case 0x51:	/* B_Bi_L0_8x16 */
			case 0x52:	/* B_Bi_L1_16x8 */
			case 0x53:	/* B_Bi_L1_8x16 */
			case 0x54:	/* B_Bi_Bi_16x8 */
			case 0x55:	/* B_Bi_Bi_8x16 */
				return 2;
			case 0x56:	/* B_8x8 */
				return 4;
			case 0x7e:	/* B_SKIP */
				return 4;
			case 0x7f:	/* P_SKIP */
				return 1;
			/* in other cases returns junk */
		}
	}
	int spcnt(int idx) {
		if (pcnt() < 4) {
			return 1;
		} else if ($mbtype == 0 || $mbtype == 0x19) { /* I_NxN or I_PCM */
			return ($mbflags[3:3] ? 1 : 4); /* transform_size_8x8_flag */
		} else {
			smt = $submbtype >> (idx * 4)) & 0xf;
			/* XXX */
		}
	}
	int mbpartmode_16x8() {
		switch ($mbtype) {
			case 0x21: /* P_L0_L0_16x8 */
			case 0x44: /* B_L0_L0_16x8 */
			case 0x46: /* B_L1_L1_16x8 */
			case 0x48: /* B_L0_L1_16x8 */
			case 0x4a: /* B_L1_L0_16x8 */
			case 0x4c: /* B_L0_Bi_16x8 */
			case 0x4e: /* B_L1_Bi_16x8 */
			case 0x50: /* B_Bi_L0_16x8 */
			case 0x52: /* B_Bi_L1_16x8 */
			case 0x54: /* B_Bi_Bi_16x8 */
				return 1;
			default:
				return 0;
		}
	}
	int submbpartmode_8x4(int idx) {
		smt = $submbtype >> (idx * 4) & 0xf;
		switch(submbtype) {
			/* XXX */
		}
	}
	int mbpartpredmode(int idx) {
		/* XXX */
	}
	/* end of helper functions */
	table = src2 & 0xf;
	if (table < 8) {
		which = src1 & 1;
		switch (table & 3) {
			case 0: result = (which ? $mvxl1 : $mvxl0); break;
			case 1: result = (which ? $mvyl1 : $mvyl0); break;
			case 2: result = (which ? $refl1 : $refl0); break;
			case 3: result = (which ? $rpil1 : $rpil0); break;
		}
		if ((table & 4) && $mbtype == 0x7f)
			result = 0;
		presult = result & 1;
	} else if (table == 8) {	/* pcnt */
		idx = src1 & 7;
		if (idx < 4) {
			result = spcnt(idx);
		} else {
			result = pcnt();
		}
	} else if (table == 9 || table == 10) {
		pidx = src1 & 7;
		sidx = src1 >> 8 & 3;
		if (table == 9) {	/* spidx */
			if (mbpartmode_16x8())
				resp = (pidx & 1) << 1;
			else
				resp = (pidx & 3);
			if (submbpartmode_8x4(resp >> 2))
				ress = (sidx & 1) << 1;
			else
				ress = (sidx & 3);
			result = resp << 2 | ress;
			presult = result & 1;
		} else {		/* pnext */
			if (pidx < 4) {
				c = spcnt(idx);
			} else {
				c = pcnt();
			}
			ress = sidx + 1;
			if (ress >= c) {
				resp = (pidx & 3) + 1;
				ress = 0;
			} else {
				resp = pidx & 3;
			}
			result = ress << 8 | resp;
			presult = ress != 0;
		}
	} else if (table == 10) {	/* pmode */
		result = mbpartpredmode(src1 & 3);
		presult = result & 1;
	} else {
		result = 0;
		presult = 0;
	}
	dst = result;
	pdst = presult;
Execution time: 1 cycle
Predicate output:
	Tables 0-9 and 11-15: bit 0 of the result
	Table 10: 1 if transition to next subpartition in a partition, 0 if
		  transition to next partition


== Minmax instructions: min, max ==

These instructions perform the signed min/max operations.

Instructions:
	min pdst, dst, src1, src2	OP=11101 [VP3+ only]
	max pdst, dst, src1, src2	OP=11110 [VP3+ only]
Opcode: base opcode, OP as above
Operation:
	if (op == min) which = (SEX(src2) < SEX(src1));
	if (op == max) which = (SEX(src2) >= SEX(src1));
	dst = (which ? src2 : src1);
	pdst = which;
Execution time: 1 cycle
Predicate output: 0 if src1 is selected as the result, 1 if src2 is selected


== Predicate instructions: and, or, xor ==

These instruction perform the corresponding logical ops on $p registers. Note
that one of both inputs can be negates, as mentioned in psrc1/psrc2 operand
description.

Instructions:
	and spdst, psrc1, psrc2		OP=xxx00
	or spdst, psrc1, psrc2		OP=xxx01
	xor spdst, psrc1, psrc2		OP=xxx10
Opcode: special opcode with OC=010, OP as above. Note that bits 2 and 3 of OP
        are used for psrc1 and psrc2 negation flags.
Operation:
	if (op == and) spdst = psrc1 & psrc2;
	if (op == or) spdst = psrc1 | psrc2;
	if (op == xor) spdst = psrc1 ^ psrc2;
Execution time: 1 cycle


== No operation: nop ==

Does nothing.

Instructions:
	nop				OP=xxx11
Opcode: special opcode with OC=010, OP as above.
Operation:
	/* nothing */
Execution time: 1 cycle


== Long multiplication instructions: lmulu, lmuls ==

These instructions perform signed and unsigned 16x11 -> 32 bit multiplication.
src1 holds the 16-bit source, while low 11 bits of src2 hold the 11-bit
source. The result is written to $lhi:$llo.

Instructions:
	lmulu src1, src2		OP=00000
	lmuls src1, src2		OP=00001
Opcode: special opcode with OC=101, OP as above
Operation:
	if (op == umul) {
		result = src1 * (src2 & 0x7ff);
	if (op == smul) {
		/* sign extension from 11-bit number */
		s2 = src2 & 0x7ff;
		if (s2 & 0x400)
			s2 -= 0x800;
		result = SEX(src1) * s2;
	}
	$llo = result;
	$lhi = result >> 16;
Execution time: 3 cycles
Execution unit conflicts: lmulu, lmuls, lsrr, ladd, lsar, ldivu


== Long arithmetic unary instructions: lsrr, ladd, lsar, ldivu ==

These instruction operate on the 32-bit quantity in $lhi:$llo. ladd adds
a signed 16-bit quantity to it. lsar shifts it right arithmetically by
a given amount. ldivu does an unsigned 32/16 -> 32 division. lsrr divides
it by 2^(src2 + 1), rounding to nearest with ties rounded up.

Instructions:
	lsrr src2		OP=00010
	ladd src2		OP=00100 [VP3+ only]
	lsar src2		OP=01000 [VP3+ only]
	ldivu src2		OP=01100 [VP4 only]
Opcode: special opcode with OC=101, OP as above
Operation:
	val = SEX($lhi) << 16 | $llo;
	if (op == lsrr) {
		bit = src2 & 0x1f;
		val += 1 << bit;
		val >>= (bit + 1);
	}
	if (op == ladd) val += SEX(src2);
	if (op == lsar) val >>= src2 & 0x1f;
	if (op == ldivu)
		val &= 0xffffffff;
		if (src2)
			val /= src2;
		else
			val = 0xffffffff;
	}
	$llo = val;
	$lhi = val >> 16;
Execution time:
	lsrr: 1 cycle
	ladd: 1 cycle
	lsar: 1 cycle
	ldivu: 34 cycles
Execution unit conflicts: lmulu, lmuls, lsrr, ladd, lsar, ldivu

        
** Override instructions **
Known override instructions control machine state, access memory spaces, external components or perform operations on predicates.


* Flow:
    0x00: [bra TARGET]
          bra IMM?
        Branch to address.
        Delay: 1 instruction
    
    0x02: [call TARGET]
          call IMM?
        XXX: stack and calling convention
    0x03: [ret]
          ret
        TODO: delay (blob: 1)
        XXX: stack and calling convention
   
* Memory
    0x80: [st DST SRC]
		  st MEM[IMM10] GPREG
		  st MEM[GPREG] GPREG
		  st MEM[GPREG + IMM10] GPREG
		  st MEM[GPREG + GPREG] GPREG
		Predicated exceptions:
		  PRED st MEM[IMM6] GPREG
		  PRED st MEM[GPREG + IMM6] GPREG
        Store data into memory. If instruction is predicated, the immediate value will be shorter.
            DST := SRC
        Delay: immediate
    
    0x81: [ld DST SRC]
          ld GPREG MEM[IMM10]
          ld GPREG MEM[GPREG]
          ld GPREG MEM[GPREG + IMM10]
          ld GPREG MEM[GPREG + GPREG]
        Predicated exceptions:
          PRED ld GPREG MEM[IMM6]
          PRED ld GPREG MEM[GPREG + IMM6]
        Load data from memory MEM. If instruction is predicated, immediate is shorter.
            DST := SRC
        Delay: 2 * MOV. Value is being read immediately (or it seems so), delay applies to DST update.

        
* IO
    0x8f: [iord DST SRC]
          iord GPREG IO[IMM10]
          iord GPREG IO[GPREG]
          iord GPREG IO[GPREG + IMM10]
          iord GPREG IO[GPREG + GPREG]
        Predicated exceptions:
          PRED iord GPREG IO[IMM6]
          PRED iord GPREG IO[GPREG + IMM6]
        Read data from IO address space - a copy of [ld] instruction. If predicated, immediate is shorter.
        XXX: verify predicated forms
            DST := SRC
        Delay: 2 * MOV. Value is being read immediately (or it seems so), delay applies to DST update.
    
    0x8e: [iowr DST SRC]
          iowr IO[IMM10] GPREG
          iowr IO[GPREG] GPREG
          iowr IO[GPREG + IMM10] GPREG
        Predicated exceptions:
          PRED iowr IO[IMM6] GPREG
          PRED iowr IO[GPREG + IMM6] GPREG
        Write data into IO address space. If instruction is predicated, the immediate value will be shorter.
        XXX: verify all forms
            DST := SRC
        Delay: immediate
        
        
* Unknown
    0x83: I/O? Memory load type
        Memory space unknown, labeled F.
        Composed of 8-byte structures.
        XXX: address space size
        Delay: 2 * MOV
    
    0x89: I/O? Memory load type
        Memory space unknown, labeled G.
        Composed of 8-byte structures.
        XXX: address space size
        Delay: 2 * MOV
    
    0x84: I/O? Memory store type.
          [8:12]: (0, 2, 3, 4, 5)
          [16:20]: all
          [20:24]: (0, 1, 2)
          [25]: 1, 0 # extra 1
          [26:]: const

    0x8d: I/O? Memory load type.
        Always yields 2. Only used in h264, only in the form of 0x1c05008d.
        Blob ORs it with [$sr28|$sr29] ored with [0x8|0x4], then writes to E[2].
        Delay: 2 * MOV
        
        
    0x04: I/O?
        Version 0x34f00004 stops execution. I/O wait? Reads from $sr6 afterwards, always preceded by unk20
    0x05: I/O?
        Usage: alternated with $sr6 writes.
    0x24: I/O
        no params (?)
        First run: change $sr16-$sr21, $sr24 and $sr27-$sr31.
        Consecutive runs: change $sr16-$sr24 and $sr27-$sr31 ($sr22, $sr23 == 1).
        XXX: delay (blob: 5)
