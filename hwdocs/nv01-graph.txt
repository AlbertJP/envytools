TOC

0. Introduction
1. NV01/NV03 graph object types
2. Graphics context
2.1. Channel context
2.2. Graph object options
2.2.1. NV01 graph object options
2.2.2. NV03 graph object options
2.2.3. NV04+ graph object structure
3. Notifiers
3.1. NOTIFY method
3.2. DMA_NOTIFY method
3.3. NOP method
4. Color and monochrome formats
4.1. COLOR_FORMAT method
4.2. Color format conversions
4.3. Monochrome formats
5. Context objects
5.1. BETA
5.2. ROP
5.3. CHROMA and PLANE
5.4. CLIP
5.5. PATTERN
5.6. BETA4
5.7. Surface setup
5.7.1. SURF
5.7.2. SURF2D
5.7.3. SURF3D
5.7.4. SWZSURF
6. The 2D rendering pipeline
7. Solid rendering objects
7.1. POINT
7.2. LINE and LIN
7.3. TRI
7.4. RECT
8. GDI object
9. Drawing images from CPU
9.1. IFC
9.2. SIFC
9.3. BITMAP
9.4. IIFC
10. Image transfer and transform objects
10.1. BLIT
10.2. IFM
10.3. SIFM
10.4. ITM
10.5. M2MF
11. NV01 3D objects
11.1. TEXLIN
11.2. TEXQUAD
11.3. TEXLINBETA
11.4. TEXQUADBETA
12. NV03 3D objects
12.1. ZPOINT
12.2. D3D


= Introduction =

[XXX: write me]

[XXX: WAIT_FOR_IDLE and PM_TRIGGER]


= NV01/NV03 graph object types =

The following graphics objects exist on NV01:

objtype type name - description
0x01 C BETA - sets beta factor for blending
0x02 C ROP - sets raster operation
0x03 C CHROMA - sets chroma key color
0x04 C PLANE - sets the plane mask
0x05 C CLIP - sets clipping rectangle
0x06 C PATTERN - sets pattern, ie. a small repeating image used as third input
       to raster operation
0x08 R POINT - renders single points
0x09 R LINE - renders solid lines
0x0a R LIN - renders solid lins [ie. lines missing a pixel on one end]
0x0b R TRI - renders solid triangles
0x0c R RECT - renders solid rectangles
0x0d 3 TEXLIN - renders quads with linearly-mapped textures [XXX]
0x0e 3 TEXQUAD - renders quads with quadratically-mapped textures [XXX]
0x10 T BLIT - copies rectangles of pixels from one place in framebuffer
       to another
0x11 T IFC - Image From CPU, uploads a rectangle of pixels via methods
0x12 T BITMAP - uploads and expands a bitmap [ie. 1bpp image] via methods
0x13 T IFM - Image From Memory, uploads a rectangle of pixels from a DMA object
0x14 T ITM - Image To Memory, downloads a rectangle of pixels to a DMA object
0x1d 3 TEXLINBETA - renders lit quads with linearly-mapped textures [XXX]
0x1e 3 TEXQUADBETA - renders lit quads with quadratically-mapped textures [XXX]

And on NV03/NV03T:

0x01 C BETA - sets beta factor for blending
0x02 C ROP - sets raster operation
0x03 C CHROMA - sets chroma key color
0x04 C PLANE - sets ??? color [XXX]
0x05 C CLIP - sets clipping rectangle
0x06 C PATTERN - sets pattern, ie. a small repeating image used as third input
       to raster operation
0x07 R RECT - renders solid rectangles
0x08 R POINT - renders single points
0x09 R LINE - renders solid lines
0x0a R LIN - renders solid lins [ie. lines missing a pixel on one end]
0x0b R TRI - renders solid triangles
0x0c R GDI - renders Windows 95 primitives: rectangles and characters, with
       font read from a DMA object
0x0d T M2MF - copies data from one DMA object to another
0x0e T SIFM - Scaled Image From Memory, like NV01's IFM, but with scaling
0x10 T BLIT - copies rectangles of pixels from one place in framebuffer
       to another
0x11 T IFC - Image From CPU, uploads a rectangle of pixels via methods
0x12 T BITMAP - uploads and expands a bitmap [ie. 1bpp image] via methods
0x14 T ITM - Image To Memory, downloads a rectangle of pixels to a DMA object
0x15 T SIFC - Stretched Image From CPU, like IFC, but with image stretching
0x17 3 D3D - Direct3D 5 textured triangles [XXX: check D3D version]
0x18 3 ZPOINT - renders single points to a surface with depth buffer
0x1c C SURF - sets rendering surface parameters

C - context object
R - 2d rendering
T - image transfer/transformation
3 - 3D rendering

[XXX: NV04+]


= The graphics context =

[XXX: write something here]


== Channel context ==

The following information makes up non-volatile graphics context. This state
is per-channel and thus will apply to all objects on it, unless software does
trap-swap-restart trickery with object switches. It is guaranteed to be
unaffected by subchannel switches and object binds. Some of this state can be
set by submitting methods on the context objects, some can only be set by
accessing PGRAPH context registers.

 - the beta factor - set by BETA object [XXX: size]
 - the 8-bit raster operation - set by ROP object
 - the A1R10G10B10 color for chroma key - set by CHROMA object
 - the A1R10G10B10 color for plane mask - set by PLANE object
 - the user clip rectangle - set by CLIP object:
   - [XXX: fill me]
 - the pattern state - set by PATTERN object:
   - shape: 8x8, 64x1, or 1x64
   - 2x A8R10G10B10 pattern color
   - the 64-bit pattern itself
 - the NOTIFY DMA object - pointer to DMA object used by NOTIFY methods.
   NV01 only - moved to graph object options on NV03+. Set by direct PGRAPH
   access only.
 - the main DMA object - pointer to DMA object used by IFM and ITM objects.
   NV01 only - moved to graph object options on NV03+. Set by direct PGRAPH
   access only.
 - On NV01, framebuffer setup - set by direct PGRAPH access only:
   - [XXX: fill me]
 - On NV03+, rendering surface setup:
   - [XXX: fill me]
   There are 4 copies of this state, one for each surface used by PGRAPH:
   - DST - the 2d destination surface
   - SRC - the 2d source surface [used by BLIT object only]
   - COLOR - the 3d color surface
   - ZETA - the 3d depth surface
   Note that the M2MF source/destination, ITM destination, IFM/SIFM source,
   and D3D texture don't count as surfaces - even though they may be
   configured to access the same data as surfaces on NV03+, they're accessed
   through the DMA circuitry, not the surface circuitry, and their setup
   is part of volatile state.
 - [XXX: figure out the extra clip stuff, etc.]
 - [XXX: update for NV04+]


== Graph object options ==

In addition to the per-channel state, there is also per-object non-volatile
state, called graph object options. This state is stored in the RAMHT entry
for the object [NV01], or in a RAMIN structure [NV03-]. On subchannel switches
and object binds, the PFIFO will send this state [NV01] or the pointer to this
state [NV03-] to PGRAPH via method 0. On NV01:NV04, this state cannot be
modified by any object methods and requires RAMHT/RAMIN access to change.
On NV04+, PGRAPH can bind DMA objects on its own when requested via methods,
and update the DMA object pointers in RAMIN. On NV05+, PGRAPH can modify
most of this state when requested via methods. All NV04+ automatic options
modification methods can be disabled by software, if so desired.


=== NV01 graph object options ===

On NV01, graph objects come with a 16-bit options field. The field is stored
in the RAMHT structure, and is thus automatically passed to PGRAPH via
method 0 by PFIFO when the active object changes for any reason. The bits in
the options field are:

  bits 0-4: OP - selects the operation to perform on the color from rendering
            pipeline before writing it to the framebuffer
    0x00: RPOP_DS - RPOP(DST, SRC)
    0x01: ROP_SDD - ROP(SRC, DST, DST)
    0x02: ROP_DSD - ROP(DST, SRC, DST)
    0x03: ROP_SSD - ROP(SRC, SRC, DST)
    0x04: ROP_DDS - ROP(DST, DST, SRC)
    0x05: ROP_SDS - ROP(SRC, DST, SRC)
    0x06: ROP_DSS - ROP(DST, SRC, SRC)
    0x07: ROP_SSS - ROP(SRC, SRC, SRC)
    0x08: ROP_SSS_ALT - ROP(SRC, SRC, SRC)
    0x09: ROP_PSS - ROP(PAT, SRC, SRC)
    0x0a: ROP_SPS - ROP(SRC, PAT, SRC)
    0x0b: ROP_PPS - ROP(PAT, PAT, SRC)
    0x0c: ROP_SSP - ROP(SRC, SRC, PAT)
    0x0d: ROP_PSP - ROP(PAT, SRC, PAT)
    0x0e: ROP_SPP - ROP(SRC, PAT, PAT)
    0x0f: RPOP_SP - ROP(SRC, PAT)
    0x10: ROP_DSP - ROP(DST, SRC, PAT)
    0x11: ROP_SDP - ROP(SRC, DST, PAT)
    0x12: ROP_DPS - ROP(DST, PAT, SRC)
    0x13: ROP_PDS - ROP(PAT, DST, SRC)
    0x14: ROP_SPD - ROP(SRC, PAT, DST)
    0x15: ROP_PSD - ROP(PAT, SRC, DST)
    0x17: SRCCOPY - SRC [no operation]
    0x18: BLEND_SS - BLEND(SRC, SRC) [XXX check]
    0x19: BLEND_DS - BLEND(DST, SRC)
    0x1a: BLEND_SD - BLEND(SRC, DST)
    0x1b: BLEND_PS - BLEND(PAT, SRC)
    0x1c: BLEND_SP - BLEND(SRC, PAT)
    0x1d: BLEND_US - BLEND(???, SRC) [XXX]
    0x1e: BLEND_SU - BLEND(SRC, ???) [XXX]
  bit 5: CHROMA - if set, enables the chroma key pipeline stage
  bit 6: PLANE - if set, enables the plane mask pipeline stage [XXX]
  bit 7: CLIP - if set, enables clipping to the user clip rectangle set via
         the CLIP object
  bit 8: NOTIFY_VALID - if set, NOTIFY method will be enabled. If unset, NOTIFY
         method will cause an interrupt. Can be used by the driver to emulate
         per-object DMA_NOTIFY setting - this flag will be set on objects whose
         emulated DMA_NOTIFY value matches the one currently in PGRAPH context,
	 and interrupt will cause a switch of the PGRAPH context value followed
	 by a method restart.
  bits 9-12: COLOR_FORMAT - selects the color format to use for decoding this
         object's methods and data sent to/from DMA objects. Does *not* affect
         framebuffer format - this is decided by PFB.
    0: X1R5G5B5_A1R5G5B5 - 16bpp, 5 bits per channel, maybe 1 bit for alpha
    1: X8R8G8B8_A8R8G8B8 - 32bpp, 8 bits per channel, maybe 8 bits for alpha
    2: X2R10G10B10_A2R10G10B10 - 32bpp, 10 bits per channel, maybe 2 bits for
       alpha
    3: Y8_A8Y8 - 8bpp [no alpha] or 16bpp [alpha], single 8-bit color channel,
       maybe 8 bits for alpha
    4: Y16_A16Y16 - 16bpp [no alpha] or 32bpp [alpha], single 16-bit color
       channel, maybe 16 bits for alpha
  bit 13: ALPHA - enables alpha channel for input. If 0, the color format
          variant without alpha will be used, and alpha value passed down will
	  be forced to full [ie. 0xff]. If 1, the color format variant with
	  alpha will be used.
  bit 14: MONO_FORMAT - selects monochromatic image input format for the
          PATTERN and BITMAP objects:
    0: LE - the leftmost pixel in each byte will be in bit 0, the next one in
          bit 1, and so on.
    1: CGA6 - the leftmost pixel in each byte will be in bit 7, the next one in
          bit 6, and so on.
    In both formats, the leftmost 8 pixels are in byte 0, next 8 pixels in
    byte 1, and so on.
  bit 15: SUBCONTEXT_ID - can be used to emulate more than one PGRAPH context
    on one channel. When an object is bound and its SUBCONTEXT_ID doesn't
    match PGRAPH's current SUBCONTEXT_ID, a context switch interrupt is raised
    to allow software to load an alternate context.


=== NV03 graph object options ===

On NV03, object options were expanded and moved to a memory structure in
RAMIN. The data stored in RAMHT and passed to PGRAPH is just a [shifted]
pointer to the grobj structure. Most importantly, the DMA objects bound
to the graph object are now stored in the options structure and don't have
to be swapped by software on every graphics object switch. The graph
object options structure is made of 3 32-bit words aligned on 0x10-byte
bounduary:

word 0:
  [XXX: figure out the bits, should be similiar to the NV01 options]

word 1:
  bits 0-15: main DMA object. This is used for GDI, SIFM, ITM, D3D, M2MF.
    For M2MF, this is the source [XXX: check] DMA object.
  bits 16-31: NOTIFY DMA object.

word 2:
  bits 0-15: secondary DMA object. This is used for M2MF destination DMA
    object. [XXX: check]

The options structure, and thus also the graph object, is selected by the
structure address in RAMIN shifted right by 4 bits. Thus graph object 0x1234
has its options structure at RAMIN address 0x12340.


=== NV04+ graph object structure ===

[XXX: write me]


== Volatile state ==

In addition to the non-volatile state described above, PGRAPH also has plenty
of "volatile" state. This state deals with the currently requested operation
and may be destroyed by switching to a new subchannel or binding a new object
[though not by full channel switches - the channels are supposed to be
independent after all, and kernel driver is supposed to save/restore all
state, including volatile state].

Volatile state is highly object-specific, but common stuff is listed here:

 - the "notifier write pending" flag and requested notification type
[XXX: more stuff?]


= Notifiers =

The notifiers are 16-byte memory structures accessed via DMA objects, used
for synchronization. Notifiers are written by PGRAPH when certain operations
are completed. Software can poll on the memory structure, waiting for it
to be written by PGRAPH. The notifier structure is:

base+0x0: 64-bit timestamp - written by PGRAPH with current PTIMER time as of
          the notifier write. The timestamp is a concatenation of current
          values of TIME_LOW and TIME_HIGH registers [see ptimer.txt].
          When big-endian mode is in effect, this becomes a 64-bit
	  big-endian number as expected. [XXX: at least on NV50]
base+0x8: 32-bit word always set to 0 by PGRAPH. This field may be used by
          software to put a non-0 value for software-written error-caused
	  notifications.
base+0xc: 32-bit word always set to 0 by PGRAPH. This is used for
          synchronization - the software is supposed to set this field to
	  a non-0 value before submitting the notifier write request,
	  then wait for it to become 0. Since the notifier fields are written
	  in order, it is guaranteed that the whole notifier structure has
	  been written by the time this field is set to 0.

There are two types of notifiers: ordinary notifiers [NV01-] and M2MF notifiers
[NV03-]. Normal notifiers are written when explicitely requested by the NOTIFY
method, M2MF notifiers are written on M2MF transfer completion. M2MF notifiers
cannot be turned off, thus it's required to at least set up a notifier DMA
object if M2MF is used, even if the software doesn't wish to use notifiers
for synchronization.

[XXX: figure out NV20 mysterious warning notifiers]

The notifiers are always written to the currently bound notifier DMA object.
The M2MF notifiers share the DMA object with ordinary notifiers. The layout
of the DMA object used for notifiers is fixed:

0x00: ordinary notifier #0
0x10: M2MF notifier [NV03-]
[XXX: 0x20 - NV20 warning notifier?]
0x20: ordinary notifier #2 [NV03:NV04 only]
0x30: ordinary notifier #3 [NV03:NV04 only]
0x40: ordinary notifier #4 [NV03:NV04 only]
0x50: ordinary notifier #5 [NV03:NV04 only]
0x60: ordinary notifier #6 [NV03:NV04 only]
0x70: ordinary notifier #7 [NV03:NV04 only]
0x80: ordinary notifier #8 [NV03:NV04 only]
0x90: ordinary notifier #9 [NV03:NV04 only]
0xa0: ordinary notifier #10 [NV03:NV04 only]
0xb0: ordinary notifier #11 [NV03:NV04 only]
0xc0: ordinary notifier #12 [NV03:NV04 only]
0xd0: ordinary notifier #13 [NV03:NV04 only]
0xe0: ordinary notifier #14 [NV03:NV04 only]
0xf0: ordinary notifier #15 [NV03:NV04 only]

Note that the notifiers always have to reside at the very beginning of the DMA
object. On NV01 and NV04+, this effectively means that only 1 notifier of each
type can be used per DMA object, requiring mulitple DMA objects if more than
one notifier per type is to be used, and likely requiring a dedicated DMA
object for the notifiers. On NV03:NV04, up to 15 ordinary notifiers may be used
in a single DMA object, though that DMA object likely still needs to be
dedicated for notifiers, and only one of the notifiers supports interrupt
generation.


== NOTIFY method ==

Ordinary notifiers are requested via the NOTIFY method. Note that the NOTIFY
method schedules a notifier write on completion of the method *following* the
NOTIFY - NOTIFY merely sets "a notifier write is pending" state.

It is an error if a NOTIFY method is followed by another NOTIFY method,
a DMA_NOTIFY method, an object bind, or a subchannel switch.

In addition to a notifier write, the NOTIFY method may also request a NOTIFY
interrupt to be triggered on PGRAPH after the notifier write.

mthd 0x104: NOTIFY [all NV01:NVC0 graph objects]
  Requests a notifier write and maybe an interrupt. The write/interrupt will
  be actually performed after the *next* method completes. Possible parameter
  values are:
    0: WRITE - write ordinary notifier #0
    1: WRITE_AND_AWAKEN - write ordinary notifier 0, then trigger NOTIFY
       interrupt [NV03-]
    2: WRITE_2 - write ordinary notifier #2 [NV03:NV04]
    3: WRITE_3 - write ordinary notifier #3 [NV03:NV04]
    [...]
    15: WRITE_15 - write ordinary notifier #15 [NV03:NV04]
Operation:
	if (!cur_grobj.NOTIFY_VALID) {
		/* DMA notify object not set, or needs to be swapped in by sw */
		throw(INVALID_NOTIFY);
	} else if ((param > 0 && chipset == NV01)
			|| (param > 15 && chipset >= NV03 && chipset < NV04)
			|| (param > 1 && chipset >= NV04)) {
		/* XXX: what state is changed? */
		throw(INVALID_VALUE);
	} else if (NOTIFY_PENDING) {
		/* tried to do two NOTIFY methods in row */
		/* XXX: what state is changed? */
		throw(DOUBLE_NOTIFY);
	} else {
		NOTIFY_PENDING = 1;
		NOTIFY_TYPE = param;
	}

After every method other than NOTIFY and DMA_NOTIFY, the following is done:
	if (NOTIFY_PENDING) {
		int idx = NOTIFY_TYPE;
		if (idx == 1)
			idx = 0;
		dma_write64(NOTIFY_DMA, idx*0x10+0x0, PTIMER.TIME_HIGH << 32 | PTIMER.TIME_LOW);
		dma_write32(NOTIFY_DMA, idx*0x10+0x8, 0);
		dma_write32(NOTIFY_DMA, idx*0x10+0xc, 0);
		if (NOTIFY_TYPE == 1)
			irq_trigger(NOTIFY);
		NOTIFY_PENDING = 0;
	}

if a subchannel switch or object bind is done while NOTIFY_PENDING is set,
CTXSW_NOTIFY error is raised.

NOTE: NV01 has a 1-bit NOTIFY_PENDING field, allowing it to do notifier writes
with interrupts, but lacks support for setting it via the NOTIFY method. This
functionality thus has to be emulated by the driver if needed.


== DMA_NOTIFY method ==

On NV04+, the notifier DMA object can be bound by submitting the DMA_NOTIFY
method. This functionality can be disabled by the driver in PGRAPH settings
registers if not desired.

mthd 0x180: DMA_NOTIFY [all NV04:NVC0 graph objects]
  Sets the notifier DMA object. When submitted through PFIFO, this method
  will undergo handle -> address translation via RAMHT.
Operation:
	if (DMA_METHODS_ENABLE) {
		/* XXX: list the validation checks */
		NOTIFY_DMA = param;
	} else {
		throw(INVALID_METHOD);
	}


== NOP method ==

On NV04+ a NOP method was added to enable asking for a notifier write without
having to submit an actual method to the object. The NOP method does nothing,
but still counts as a graph object method and will thus trigger a notifier
write/interrupt if one was previously requested.

mthd 0x100: NOP [all NV04+ graph objects]
  Does nothing.
Operation:
	/* nothing */
[XXX: figure out if this method can be disabled for NV01 compat]


= Color and monochrome formats =

[XXX: write me]


== COLOR_FORMAT methods ==

mthd 0x300: COLOR_FORMAT [NV01_CHROMA, NV01_PATTERN] [NV04-]
  Sets the color format using NV01 color enum.
Operation:
	cur_grobj.COLOR_FORMAT = get_nv01_color_format(param);
[XXX: figure out this enum]

mthd 0x300: COLOR_FORMAT [NV04_CHROMA, NV04_PATTERN]
  Sets the color format using NV04 color enum.
Operation:
	cur_grobj.COLOR_FORMAT = get_nv04_color_format(param);
[XXX: figure out this enum]


== Color format conversions ==

[XXX: write me]


== Monochrome formats ==

[XXX: write me]

mthd 0x304: MONO_FORMAT [NV01_PATTERN] [NV04-]
  Sets the monochrome format.
Operation:
	if (param != LE && param != CGA6)
		throw(INVALID_ENUM);
	cur_grobj.MONO_FORMAT = param;
[XXX: check]


= Context objects =

[XXX: a little description]


== BETA ==

The BETA object family deals with setting the beta factor for the BLEND
operation. The objects in this family are:

 - objtype 0x01: NV01_BETA [NV01:NV04]
 - class 0x0012: NV01_BETA [NV04:NV84]

The methods are:

0100   NOP [NV04-]
0104   NOTIFY
0110   WAIT_FOR_IDLE [NV50-]
0140   PM_TRIGGER [NV40-?] [XXX]
0180 N DMA_NOTIFY [NV04-]
0200 O PATCH_BETA_OUTPUT [NV04:NV20]
0300   BETA

mthd 0x300: BETA [NV01_BETA]
  Sets the beta factor. The parameter is a signed fixed-point number with
  a sign bit and 31 fractional bits. Note that negative values are clamped
  to 0, and only 8 fractional bits are actually implemented in hardware.
Operation:
	if (param & 0x80000000) /* signed < 0 */
		BETA = 0;
	else
		BETA = param & 0x7f800000;

mthd 0x200: PATCH_BETA_OUTPUT [NV01_BETA] [NV04:NV20]
  Reserved for plugging a beta patchcord to output beta factor into.
Operation:
	throw(UNIMPLEMENTED_MTHD);


== ROP ==

The ROP object family deals with setting the ROP [raster operation]. The ROP
value thus set is only used in the ROP_* operation modes. The objects in this
family are:

 - objtype 0x02: NV01_ROP [NV01:NV04]
 - class 0x0043: NV01_ROP [NV04:NV84]

The methods are:

0100   NOP [NV04-]
0104   NOTIFY
0110   WAIT_FOR_IDLE [NV50-]
0140   PM_TRIGGER [NV40-?] [XXX]
0180 N DMA_NOTIFY [NV04-]
0200 O PATCH_ROP_OUTPUT [NV04:NV20]
0300   ROP

mthd 0x300: ROP [NV01_ROP]
  Sets the raster operation.
Operation:
	if (param & ~0xff)
		throw(INVALID_VALUE);
	ROP = param;

mthd 0x200: PATCH_ROP_OUTPUT [NV01_ROP] [NV04:NV20]
  Reserved for plugging a ROP patchcord to output the ROP into.
Operation:
	throw(UNIMPLEMENTED_MTHD);


== CHROMA and PLANE ==

The CHROMA object family deals with setting the color for the color key. The
color key is only used when enabled in options for a given graph object. The
objects in this family are:

 - objtype 0x03: NV01_CHROMA [NV01:NV04]
 - class 0x0017: NV01_CHROMA [NV04:NV50]
 - class 0x0057: NV04_CHROMA [NV04:NV84]

The PLANE object family deals with setting the color for plane masking. The
plane mask operation is only done when enabled in options for a given graph
object. The objects in this family are:

 - objtype 0x04: NV01_PLANE [NV01:NV04]

For both objects, colors are internally stored in A1R10G10B10 format. [XXX:
check NV04+]

The methods for these families are:

0100   NOP [NV04-]
0104   NOTIFY
0110   WAIT_FOR_IDLE [NV50-]
0140   PM_TRIGGER [NV40-?] [XXX]
0180 N DMA_NOTIFY [NV04-]
0200 O PATCH_IMAGE_OUTPUT [NV04:NV20]
0300   COLOR_FORMAT [NV04-]
0304   COLOR

mthd 0x304: COLOR [*_CHROMA, NV01_PLANE]
  Sets the color.
Operation:
	struct {
		int B : 10;
		int G : 10;
		int R : 10;
		int A : 1;
	} tmp;
	tmp.B = get_color_b10(cur_grobj, param);
	tmp.G = get_color_g10(cur_grobj, param);
	tmp.R = get_color_r10(cur_grobj, param);
	tmp.A = get_color_a1(cur_grobj, param);
	if (cur_grobj.type == NV01_PLANE)
		PLANE = tmp;
	else
		CHROMA = tmp;
[XXX: check NV03+]

mthd 0x200: PATCH_IMAGE_OUTPUT [*_CHROMA, NV01_PLANE] [NV04:NV20]
  Reserved for plugging an image patchcord to output the color into.
Operation:
	throw(UNIMPLEMENTED_MTHD);


== CLIP ==

The CLIP object family deals with setting up the user clip rectangle. The user
clip rectangle is only used when enabled in options for a given graph object.
The objects in this family are:

 - objtype 0x05: NV01_CLIP [NV01:NV04]
 - class 0x0019: NV01_CLIP [NV04:NV84]

The methods for this family are:

0100   NOP [NV04-]
0104   NOTIFY
0110   WAIT_FOR_IDLE [NV50-]
0140   PM_TRIGGER [NV40-?] [XXX]
0180 N DMA_NOTIFY [NV04-]
0200 O PATCH_IMAGE_OUTPUT [NV04:NV20]
0300   CORNER
0304   SIZE

The clip rectangle state can be loaded in two ways:
 - submit CORNER method twice, with upper-left and bottom-right corners
 - submit CORNER method with upper-right corner, then SIZE method
To enable that, clip rectangle method operation is a bit unusual.
[XXX: check if still applies on NV03+]

Note that the clip rectangle state is internally stored relative to the
absolute top-left corner of the framebuffer, while coordinates used in
methods are relative to top-left corner of the canvas.

mthd 0x300: CORNER [NV01_CLIP]
  Sets a corner of the clipping rectangle.
  bits 0-15: X coordinate
  bits 16-31: Y coordinate
Operation:
	ABS_UCLIP_XMIN = ABS_UCLIP_XMAX;
	ABS_UCLIP_YMIN = ABS_UCLIP_YMAX;
	ABS_UCLIP_XMAX = CANVAS_MIN.X + param.X;
	ABS_UCLIP_YMAX = CANVAS_MIN.Y + param.Y;
[XXX: check NV03+]

mthd 0x304: SIZE [NV01_CLIP]
  Sets the size of the clipping rectangle.
  bits 0-15: width
  bits 16-31: height
Operation:
	ABS_UCLIP_XMIN = ABS_UCLIP_XMAX;
	ABS_UCLIP_YMIN = ABS_UCLIP_YMAX;
	ABS_UCLIP_XMAX += param.X;
	ABS_UCLIP_YMAX += param.Y;
[XXX: check NV03+]

mthd 0x200: PATCH_IMAGE_OUTPUT [NV01_CLIP] [NV04:NV20]
  Reserved for plugging an image patchcord to output the rectangle into.
Operation:
	throw(UNIMPLEMENTED_MTHD);


== PATTERN ==

The PATTERN object family deals with setting up the pattern, which is used
in some ROP and BLEND configurations. The objects in this family are:

 - objtype 0x06: NV01_PATTERN [NV01:NV04]
 - class 0x0018: NV01_PATTERN [NV04:NV50]
 - class 0x0044: NV04_PATTERN [NV04:NV84]

The methods for this family are:

0100   NOP [NV04-]
0104   NOTIFY
0110   WAIT_FOR_IDLE [NV50-]
0140   PM_TRIGGER [NV40-?] [XXX]
0180 N DMA_NOTIFY [NV04-]
0200 O PATCH_IMAGE_OUTPUT [NV04:NV20]
0300   COLOR_FORMAT [NV04-]
0304   MONO_FORMAT [NV04-]
0308   SHAPE
030c   SELECT [NV04_PATTERN]
0310+i*4, i<2   MONO_COLOR
0318+i*4, i<2   MONO_PATTERN
0400+i*4, i<16  COLOR_Y8 [NV04_PATTERN]
0500+i*4, i<32  COLOR_R5G6B5 [NV04_PATTERN]
0600+i*4, i<32  COLOR_X1R5G5B5 [NV04_PATTERN]
0700+i*4, i<64  COLOR_X8R8G8B8 [NV04_PATTERN]

[XXX: describe how the pattern works]

mthd 0x308: SHAPE [*_PATTERN]
  Sets the pattern shape. One of:
    0: 8x8
    1: 64x1
    2: 1x64
Operation:
	if (param > 2)
		throw(INVALID_ENUM);
	PATTERN_SHAPE = param;
[XXX: check NV03+]

mthd 0x30c: SELECT [NV04_PATTERN]
  Sets the pattern type. One of:
    1: MONO
    2: COLOR
Operation:
	/* XXX: figure it out */

mthd 0x310+i*4, i<2: MONO_COLOR [*_PATTERN]
  Sets the colors used for mono pattern. i=0 sets the color used for pixels
  corresponding to '0' bits in the pattern, i=1 sets the color used for '1'.
Operation:
	PATTERN_MONO_COLOR[i].B = get_color_b10(cur_grobj, param);
	PATTERN_MONO_COLOR[i].G = get_color_b10(cur_grobj, param);
	PATTERN_MONO_COLOR[i].R = get_color_b10(cur_grobj, param);
	PATTERN_MONO_COLOR[i].A = get_color_b8(cur_grobj, param);
[XXX: check NV03+]

mthd 0x318+i*4, i<2: MONO_PATTERN [*_PATTERN]
  Sets the mono pattern. i=0 sets bits 0-31, i=1 sets bits 32-63.
Operation:
	b8 tmp[4];
	for (j = 0; j < 4; j++)
		tmp[j] = param >> 8*j & 0xff;
	/* pattern stored internally in LE format - for CGA6, reverse
	   bits in all bytes */
	if (cur_grobj.MONO_FORMAT == CGA6)
		for (j = 0; j < 4; j++)
			tmp[j] = reverse_bits(tmp[j]);
	for (j = 0; j < 4; j++)
		PATTERN_MONO[i*32+j*8:i*32+j*8+7] = tmp[j];
[XXX: check NV03+]

mthd 0x400+i*4, i<16: COLOR_Y8 [NV04_PATTERN]
  Sets 4 color pattern cells, from Y8 source.
  bits 0-7: color for pattern cell i*4+0
  bits 8-15: color for pattern cell i*4+1
  bits 16-23: color for pattern cell i*4+2
  bits 24-31: color for pattern cell i*4+3
Operation:
	/* XXX: figure it out */

mthd 0x500+i*4, i<32: COLOR_R5G6B5 [NV04_PATTERN]
  Sets 2 color pattern cells, from R5G6B5 source.
  bits 0-15: color for pattern cell i*2+0
  bits 16-31: color for pattern cell i*2+1
Operation:
	/* XXX: figure it out */

mthd 0x600+i*4, i<32: COLOR_X1R5G5B5 [NV04_PATTERN]
  Sets 2 color pattern cells, from X1R5G5B5 source.
  bits 0-15: color for pattern cell i*2+0
  bits 16-31: color for pattern cell i*2+1
Operation:
	/* XXX: figure it out */

mthd 0x700+i*4, i<64: COLOR_X8R8G8B8 [NV04_PATTERN]
  Sets a color pattern cell, from X8R8G8B8 source.
Operation:
	/* XXX: figure it out */

mthd 0x200: PATCH_IMAGE_OUTPUT [*_PATTERN] [NV04:NV20]
  Reserved for plugging an image patchcord to output the pattern into.
Operation:
	throw(UNIMPLEMENTED_MTHD);


== BETA4 ==

The BETA4 object family deals with setting the per-component beta factors for
the BLEND_PREMULT and SRCCOPY_PREMULT operations. The objects in this family
are:

 - class 0x0072: NV04_BETA4 [NV04:NV84]

The methods are:

0100   NOP [NV04-]
0104   NOTIFY
0110   WAIT_FOR_IDLE [NV50-]
0140   PM_TRIGGER [NV40-?] [XXX]
0180 N DMA_NOTIFY [NV04-]
0200 O PATCH_BETA_OUTPUT [NV04:NV20]
0300   BETA4

mthd 0x300: BETA4 [NV04_BETA4]
  Sets the per-component beta factors.
  bits 0-7: B
  bits 8-15: G
  bits 16-23: R
  bits 24-31: A
Operation:
	/* XXX: figure it out */

mthd 0x200: PATCH_BETA_OUTPUT [NV04_BETA4] [NV04:NV20]
  Reserved for plugging a beta patchcord to output beta factors into.
Operation:
	throw(UNIMPLEMENTED_MTHD);


== Surface setup ==

[XXX: write me]


= The 2D rendering pipeline =

[XXX: write me]


= Solid rendering objects =

[XXX: write me]


= GDI object =

[XXX: write me]


= Drawing images from CPU =

[XXX: write me]


= Image transfer and transform objects =

[XXX: write me]


= NV01 3D objects =

[XXX: write me]


= NV03 3D objects =

[XXX: write me]
