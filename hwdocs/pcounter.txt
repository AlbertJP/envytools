TOC

0. Introduction
1. MMIO registers
1.1. NV10
1.2. NV40
1.3. NVC0
2. The PCOUNTER signals
2.1. The STATUS registers
2.2. Trailer signals
2.3. The PM_TRIGGER and WRCACHE_FLUSH signals
3. Input selection
4. Counters
5. Control registers
6. Single event mode
7. Quad event mode
8. Memory write mode
9. The flag

= Introduction =

PCOUNTER is the card units that contains performance monitoring counters.
It is present on NV10+ GPUs, with the exception of NV11, NV17, NV18 for
unknown reasons [XXX: why? any others excluded? NV1A, NV25, NV2A, NV30, NV36
pending a check].

PCOUNTER is actually made of several identical hardware counter units, one
for each so-called domain. Each PCOUNTER domain can potentially run on
a different source clock, allowing one to monitor events in various clock
domains. The PCOUNTER domains are mostly independent, but there's some
limitted communication and shared circuitry among them.

There are three major revisions of PCOUNTER hardware, and some minor
subrevisions:

 - NV10:NV40 major revision:
  - NV10:NV15 - first version, one domain, only single-event mode available
  - NV15:NV20 - ??? [XXX]
  - NV20:NV30 - added second domain for events associated with memory clock
  - NV30:NV40 - removed separate clrflag/setflag input selection, changed
    from 40-bit to 32-bit counters, added quad event mode
 - NV40:NVC0 major revision:
  - NV40:NV84 - rearranged to make space for 8 domains, added ??? [XXX]
  - NV84:NV92 - added memory dump mode and swap input selection
  - NV92:NVA3 - ??? [XXX]
  - NVA3:NVC0 - ??? [XXX]
 - NVC0+ major revision:
  - NVC0+ - split PCOUNTER into hub, per-gpc and per-partition domain sets,
    ???
[XXX: figure out what else]

The inputs to PCOUNTER are various activity monitoring signals from all over
the card. The PCOUNTER hardware selects a few of them, performs programmable
logic operations on them, and aggregates it to a handful of actual counter
inputs. Some of the inputs are special and control counting start/stop, while
others are the events to be counted. PCOUNTER can be used in three modes:

 - single event mode - a single event is being counted, with fine-grained
   control of counting periods via pre-start/start/stop signals. Several
   counting periods per run may be configured, and a threshold counter may
   be used. The input signals used are:
   - PRE - a programmable amount of pulses on this input must happen before
     START is recognised
   - START - a pulse on this input starts a counting period
   - EVENT - the pulses on this input are counted
   - STOP - a pulse on this input stops a counting period
 - quad event mode [NV30-] - 4 events are being counted, with a simple "swap
   counter sets" trigger to delimit counting periods
   - PRE, START, EVENT, STOP - the pulses on these inputs are counted [in 4
     separate counters]
   - SWAP - a pulse on this input swaps counter sets, ie. copies the internal
     counters to the MMIO registers and resets internal counters to 0.
 - memory write mode [NV84-] - ??? [XXX]

The PCOUNTER uses MMIO area 0x00a000:0x00b000 on NV10:NV40 and NV40:NVC0. On
NVC0+, it uses 0x180000:0x1c0000.

PCOUNTER is unaffected by all PMC.ENABLE bits and has no interrupt lines.


= MMIO registers =

The MMIO registers are similiar among PCOUNTER revisions, but their placement
is very different.


== NV10 ==

The MMIO registers for NV10:NV40 are [i is domain index]:

00a400+i*0x100 PRE_SRC[i] - PRE input selection
00a404+i*0x100 PRE_OP[i] - PRE logic operation
00a408+i*0x100 START_SRC[i] - START input selection
00a40c+i*0x100 START_OP[i] - START logic operation
00a410+i*0x100 EVENT_SRC[i] - EVENT input selection
00a414+i*0x100 EVENT_OP[i] - EVENT logic operation
00a418+i*0x100 STOP_SRC[i] - STOP input selection
00a41c+i*0x100 STOP_OP[i] - STOP logic operation
00a420+i*0x100 SETFLAG_SRC[i] - SETFLAG input selection [NV10:NV30]
00a424+i*0x100 SETFLAG_OP[i] - SETFLAG logic operation
00a428+i*0x100 CLRFLAG_SRC[i] - CLRFLAG input selection [NV10:NV30]
00a42c+i*0x100 CLRFLAG_OP[i] - CLRFLAG logic operation
00a430+i*0x100+j*4,j<4 STATUS[i][j] - input status
00a600+i*0x100 CTR_CYCLES[i] - elapsed cycles counter
00a604+i*0x100 CTR_CYCLES_HI[i] - elapsed cycles counter high bits [NV10:NV30]
00a608+i*0x100 CTR_CYCLES_ALT[i] - CYCLES copy ??? [XXX]
00a60c+i*0x100 CTR_CYCLES_ALT_HI[i] - same, high bits [NV10:NV30]
00a610+i*0x100 CTR_EVENT[i] - EVENT counter
00a614+i*0x100 CTR_EVENT_HI[i] - EVENT counter high bits [NV10:NV30]
00a618+i*0x100 CTR_START[i] - START counter
00a61c+i*0x100 CTR_START_HI[i] - CTR_START high bits [NV10:NV30]
00a620+i*0x100 CTR_PRE[i] - PRE counter
00a624+i*0x100 CTR_STOP[i] - STOP counter
00a628+i*0x100 THRESHOLD[i] - EVENT counter threshold
00a62c+i*0x100 THRESHOLD_HI[i] - THRESHOLD high bits [NV10:NV30]
00a630+i*0x100+(j-4)*4,4<=j<8 STATUS[i][j] - input status, second part
00a738 QUAD_ACK_TRIGGER - used to ack counter data in quad event mode [NV30:NV40]
00a73c CTRL - PCOUNTER control


== NV40 ==

The MMIO registers for NV40:NVC0 are [i is domain index]:

00a400+i*4 PRE_SRC[i] - PRE input selection
00a420+i*4 PRE_OP[i] - PRE logic operation
00a440+i*4 START_SRC[i] - START input selection
00a460+i*4 START_OP[i] - START logic operation
00a480+i*4 EVENT_SRC[i] - EVENT input selection
00a4a0+i*4 EVENT_OP[i] - EVENT logic operation
00a4c0+i*4 STOP_SRC[i] - STOP input selection
00a4e0+i*4 STOP_OP[i] - STOP logic operation
00a500+i*4 SETFLAG_OP[i] - SETFLAG logic operation
00a520+i*4 CLRFLAG_OP[i] - CLRFLAG logic operation
00a540+i*4 SRC_STATUS[i] - selected inputs status
00a560+i*4 SPEC_SRC[i] - SWAP and UNK input selection [NV84-]
00a580+i*4 ??? [XXX]
00a600+i*4 CTR_CYCLES[i] - elapsed cycles counter
00a640+i*4 CTR_CYCLES_ALT[i] - CYCLES copy ??? [XXX]
00a680+i*4 CTR_EVENT[i] - EVENT counter
00a6a0+i*4 ??? [XXX]
00a6c0+i*4 CTR_START[i] - START counter
00a6e0+i*4 ??? [XXX]
00a700+i*4 CTR_PRE[i] - PRE counter
00a720+i*4 ??? [XXX]
00a740+i*4 CTR_STOP[i] - STOP counter
00a760+i*4 ??? [XXX]
00a780+i*4 THRESHOLD[i] - EVENT counter threshold
00a7a0 CHANNEL - VM channel for memory write mode [NV84-]
00a7a4 DMAOBJ - DMA object for memory write mode [NV84-]
00a7a8 ??? [XXX]
00a7c0+i*4 CTRL - PCOUNTER control
00a7e0+i*4 QUAD_ACK_TRIGGER - used to ack counter data in quad event mode
00a800+i*0x20+j*4,j<8 STATUS[i][j] - input status


== NVC0 ==

[XXX: write me]


= The PCOUNTER signals =

The raw inputs that PCOUNTER operates on are called "signals". A signal is
a single 0/1 wire sampled on every clock. The signals come from many different
areas of the card and represent various state information. Example signals may
be:

 - is unit X busy? - counting 1s on this signal together with elapsed clock
   cycles will give activity percentage for given unit
 - did microcontroller X execute an instruction this cycle? - counting 1s
   will give the number of executed instructions

The signals are grouped into so-called domains. A domain has a single base
clock and its own counting circuitry - the counting process and counter
registers are per-domain. Domains are further grouped into domain sets.
Domains within a domain set can communicate to a limitted extend. NV10:NVC0
GPUs have a single domain set, while on NVC0+ there's one domain set for each
GPC, one for each partition, and one for all domains not associated with
a GPC/partition.

On NV10:NV20, there's only one domain. On NV20:NV40 there are 2 domains.
On NV40+ there can be up to 8 domains per domain set. On all GPUs, there
can be up to 256 signals per domain. The available signals and domains
depend heavily on the chipset. The signals are packed tightly, so even
a signal common to two GPUs may be at different position between them.
The lists of known domains and signals may be found in nv10-pcounter.txt,
nv40-pcounter.txt and nvc0-pcounter.txt


== The STATUS registers ==

The STATUS registers may be used to peek at the current value of each signal.

MMIO 0x00a430 + i*0x100 + (j >> 2)*0x200 + (j&3)*4: STATUS[i][j] [NV10:NV84]
MMIO 0x00a800 + i*0x20 + j*4: STATUS[i][j] [NV50:NVC0]
MMIO domain_base+0x000 + j*4: STATUS[j] [NVC0+]
  Reading register #j gives current value of signals j*32..j*32+31 as bits
  0..31 of the read value. This register is per-domain [i is the domain id]
  and read-only. Only i and j values corresponding to actually present domains
  and signals are valid.


== Trailer signals ==

A special kind of signals is so-called "trailer signals". These signals are
common for all domains in a domain set. The position of these signals is not
exactly constant between the domains, but their position modulo 0x20 is
[ie. they're at the same position inside a STATUS reg for all domains, but
not necessarily in the same STATUS reg]. Therefore, the position of each
trailer signal here is given as an offset from "trailer base".

The trailer signals for NV10:NV20 are:

base+0x1f: PCOUNTER.FLAG - the flag

For NV20:NV40:

base+0x1d: PGRAPH.PM_TRIGGER - the PM_TRIGGER pulse from PGRAPH
base+0x1e: PCOUNTER.DOM[1].FLAG - the flag from domain 1
base+0x1f: PCOUNTER.DOM[0].FLAG - the flag from domain 0

For NV40:NVC0:

base+0x0e: PGRAPH.WRCACHE_FLUSH - the WRCACHE_FLUSH pulse from PGRAPH [NV84:NVC0]
base+0x0f: PGRAPH.PM_TRIGGER - the PM_TRIGGER pulse from PGRAPH
base+0x10: PCOUNTER.DOM[7].EVENT - the EVENT input from domain 7
base+0x11: PCOUNTER.DOM[6].EVENT - the EVENT input from domain 6
base+0x12: PCOUNTER.DOM[5].EVENT - the EVENT input from domain 5
base+0x13: PCOUNTER.DOM[4].EVENT - the EVENT input from domain 4
base+0x14: PCOUNTER.DOM[3].EVENT - the EVENT input from domain 3
base+0x15: PCOUNTER.DOM[2].EVENT - the EVENT input from domain 2
base+0x16: PCOUNTER.DOM[1].EVENT - the EVENT input from domain 1
base+0x17: PCOUNTER.DOM[0].EVENT - the EVENT input from domain 0
base+0x18: PCOUNTER.DOM[7].FLAG - the FLAG from domain 7
base+0x19: PCOUNTER.DOM[6].FLAG - the FLAG from domain 6
base+0x1a: PCOUNTER.DOM[5].FLAG - the FLAG from domain 5
base+0x1b: PCOUNTER.DOM[4].FLAG - the FLAG from domain 4
base+0x1c: PCOUNTER.DOM[3].FLAG - the FLAG from domain 3
base+0x1d: PCOUNTER.DOM[2].FLAG - the FLAG from domain 2
base+0x1e: PCOUNTER.DOM[1].FLAG - the FLAG from domain 1
base+0x1f: PCOUNTER.DOM[0].FLAG - the FLAG from domain 0

For NVC0+:

base+0x1f..0x22: PCOUNTER.MAIN.???
base+0x23..0x26: PCOUNTER.MAIN.???
base+0x27..0x2f: ???
base+0x30: PCOUNTER.DOM[7].EVENT - the EVENT input from domain 7
base+0x31: PCOUNTER.DOM[6].EVENT - the EVENT input from domain 6
base+0x32: PCOUNTER.DOM[5].EVENT - the EVENT input from domain 5
base+0x33: PCOUNTER.DOM[4].EVENT - the EVENT input from domain 4
base+0x34: PCOUNTER.DOM[3].EVENT - the EVENT input from domain 3
base+0x35: PCOUNTER.DOM[2].EVENT - the EVENT input from domain 2
base+0x36: PCOUNTER.DOM[1].EVENT - the EVENT input from domain 1
base+0x37: PCOUNTER.DOM[0].EVENT - the EVENT input from domain 0
base+0x38: PCOUNTER.DOM[7].FLAG - the FLAG from domain 7
base+0x39: PCOUNTER.DOM[6].FLAG - the FLAG from domain 6
base+0x3a: PCOUNTER.DOM[5].FLAG - the FLAG from domain 5
base+0x3b: PCOUNTER.DOM[4].FLAG - the FLAG from domain 4
base+0x3c: PCOUNTER.DOM[3].FLAG - the FLAG from domain 3
base+0x3d: PCOUNTER.DOM[2].FLAG - the FLAG from domain 2
base+0x3e: PCOUNTER.DOM[1].FLAG - the FLAG from domain 1
base+0x3f: PCOUNTER.DOM[0].FLAG - the FLAG from domain 0


== The PM_TRIGGER and WRCACHE_FLUSH signals ==

[XXX: write me]


= Input selection =

[XXX: write me]


= Counters =

[XXX: write me]


= Control registers =

[XXX: write me]


= Single event mode =

[XXX: write me]


= Quad event mode =

[XXX: write me]


= Memory write mode =

[XXX: write me]


= The flag =

[XXX: write me]
