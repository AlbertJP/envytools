TOC

0. Introduction
1. MMIO registers
2. Interrupts
3. Control and status registers
4. Method submission
5. Context
6. Surface setup
7. Drawing operation


= Intruduction =

[XXX: write me]


= MMIO registers =

[XXX: write me]


= Interrupts =

The PGRAPH registers dealing with interrupts are:

MMIO 0x400100: INTR
  Status of interrupts generated by PGRAPH. On read, returns 1 for bits
  corresponding to pending interrupts. On write, if 1 is written to a bit,
  its interrupt gets cleared, if 0 is written nothing happens.
  bit 0: INVALID - something was wrong with the submitted method. Detailed
    status is available in the INVALID register. Clearing this bit will also
    clear the INVALID register. In turn, clearing the INVALID register will
    clear this bit.
  bit 4: CONTEXT_SWITCH - a CTX_SWITCH method was submitted and the channel
    id and/or SUBCONTEXT_ID is different from the current one.
  bit 8: VBLANK - the vertical blanking period has started on PFB. This
    is really PFB's interrupt. It is delivered to a different PMC line than
    other PGRAPH interrupts. See memory/nv01-pfb.txt for details.
  bit 12: ??? [XXX: figure this out]
  bit 16: MISSING_METHOD - the final method to do an operation was submitted
    without first submitting other required methods
  bit 20: CANVAS_SOFTWARE - a drawing operation was attempted with SOFTWARE
    bit set in CANVAS_CONFIG.
  bit 24: CLIP_SOFTWARE - a drawing operation was attempted with SOFTWARE bit
    set in CLIPRECT_CTRL.
  bit 28: NOTIFY - a method on which notify interrupt was requested has been
    executed

MMIO 0x400140: INTR_EN
  Interrupt enable bitmask. Set to enable, clear to disable. Interrupts that
  are masked will still show up in INTR when they're triggered, but won't
  cause the PGRAPH or PFB interrupt line to go active. Has same bitfields
  as INTR.

Interrupts other than VBLANK are delivered to PMC interrupt line 12. VBLANK
interrupt is delivered to PMC interrupt line 24.

The INVALID interrupt is further controlled by these registers:

MMIO 0x400104: INVALID
  Status of INVALID subinterrupts. Works like INTR. Clearing this register
  will also clear the INVALID bit in INTR register. In turn, clearing INVALID
  bit in INTR will also clear this register.
  bit 0: INVALID_METHOD - the method that was submitted does not exist
  bit 4: INVALID_VALUE - the method was submitted with invalid parameter
  bit 8: INVALID_NOTIFY - a NOTIFY method was submitted, but NOTIFY_VALID
    was not set in graph object options
  bit 12: DOUBLE_NOTIFY - a NOTIFY method was submitted with NOTIFY_PENDING
    already set
  bit 16: CTXSW_NOTIFY - a CTX_SWITCH method was submitted with NOTIFY_PENDING
    set

MMIO 0x400140: INVALID_EN
  INVALID interrupt enable bitmask. Set to enable, clear to disable. Same
  bitfields as INVALID. If any interrupt active in INVALID is also enabled
  here, interrupt line to PMC will be active. Note that this register does
  *not* affect triggering the INVALID bit in INTR and the interrupt status
  from INTR&INTR_EN will be effectively ORed with INVALID&INVALID_EN. Thus
  the contents of INVALID_EN will only matter when INTR_EN.INVALID is set
  to 0.

The INTR and INVALID registers are special and can be written by host even
if ACCESS.HOST is not set.

Note that interrupts that are disabled will still cause PGRAPH to halt and
disable FIFO/HOST bits in ACCESS.


= Control and status registers =

All access to PGRAPH is controlled by the ACCESS register:

MMIO 0x4006a4: ACCESS
  bit 0: FIFO - if set to 1, PFIFO is able to write to PGRAPH's MMIO
         registers, ie. can submit methods. If set to 0, PFIFO method
	 submission to PGRAPH will be blocked until it's set back to 1.
  bit 4: DMA - if set to 1, PDMA is able to write to PGRAPH's MMIO registers,
         ie. can respond to DMA read requests. If set to 0, PDMA read data
	 will be blocked until it's set back to 1. [XXX: verify]
  bit 8: HOST - if set to 1, the host is able to write to PGRAPH's MMIO
         registers. If set to 0, writes to all registers in PGRAPH MMIO range
	 from host will be ignored, except writes to ACCESS, INTR and INVALID
	 registers. Reads to registers other than VTX_POS_* and VTX_BETA_*
	 are unaffected.
  bits 12-16: OBJECT - the type of the current object. Automatically updated
         by PGRAPH when processing method 0. [XXX: what's this for?]
  bit 24: FIFO_WR - when writing ACCESS and this bit is set to 1 in the
         written value, the FIFO field will be set as per the written value;
	 when this bit is set to 0 in the written value, the FIFO field will
	 be unaffected. When reading ACCESS, always reads as 1. This, together
	 with the following 3 bits, can be used to selectively write ACCESS
	 bitfields.
  bit 25: DMA_WR - like FIFO_WR, but for DMA field
  bit 26: HOST_WR - like FIFO_WR, but for HOST field
  bit 27: OBJECT_WR - like FIFO_WR, but for OBJECT field

Note that the FIFO and HOST bits will be automatically cleared by PGRAPH when
an interrupt is triggered by execution of a method. The host has to reenable
HOST access in the interrupt handler to manipulate any PGRAPH state.

The current busy status of PGRAPH can be checked by reading the STATUS
register:

MMIO 0x4006b0: STATUS
  bit 0: BUSY - PGRAPH is busy processing some method
  bit 4: XY_LOGIC - PGRAPH is busy calculating vertex coordinates
  bit 16: DMA - PGRAPH is busy talking to PDMA about IFM or ITM DMA
  bit 20: DMA_NOTIFY - PGRAPH is busy talking to PDMA about NOTIFY DMA
  [XXX: more bits]


= Method submission =

[XXX: write me]


= Context =

[XXX: write me]


= Surface setup =

[XXX: write me]


= Drawing operation =

[XXX: write me]
