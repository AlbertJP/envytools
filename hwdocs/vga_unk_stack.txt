TOC

0. Introduction
1. MMIO registers
2. Operation


= Introduction =

A dedicated RAM made of 0x200 8-bit cells arranged into a hw stack. NFI what
it is for, apparently related to VGA. Present on NV41+ cards.


= MMIO registers =

On NV41:NV50, the registers are located in PBUS area:

001380 VAL
001384 CTRL
001388 CONFIG
00138c SP

On NV50+, the registers are located in PDISPLAY.VGA area:

619e40 VAL
619e44 CTRL
619e48 CONFIG
619e4c SP


= Operation =

The stack is made of the following data:

 - an array of 0x200 bytes [the actual stack]
 - a 10-bit stack pointer [SP]
 - 3 config bits:
  - write push enable
  - read pop enable
  - stack read mode: SP or SP-1
 - 2 sticky error bits:
  - stack underflow
  - stack overflow

The stack grows upwards. The stack pointer points to the cell that would be
written by a push. The valid values for stack pointer are thus 0-0x200, with
0 corresponding to an empty stack and 0x200 to a full stack. If stack is ever
accessed at position >= 0x200 [which is usually an error], the address wraps
modulo 0x200.

The stack data is read or written through the VAL register:

MMIO 0x001380: VAL [NV41:NV50]
MMIO 0x619e40: VAL [NV50-]
  Accesses a stack entry. A write to this register writes the low 8 bits of
  the written value to the stack at position SP and, if WRITE_PUSH_ENABLE
  config bit is set, increments the SP by 1. If stack overflow happens, the
  stack overflow error bit is set. Operation:
	STACK[SP] = val;
	if (SP >= 0x200)
		CTRL.OVERFLOW = 1;
	if (CONFIG.WRITE_PUSH_ENABLE)
		SP++;
  A read from this register returns the stack entry at position SP or SP-1,
  depending on the READ_FROM config bit, and decrements the SP by 1 if
  READ_POP_ENABLE config bit is set. If stack underflow happens, the stack
  underflow error bit is set.
	
  Note that a read with SP==0 always counts as a stack underflow, even if
  READ_FROM is SP and READ_POP_ENABLE is not set.
  	if (CONFIG.READ_FROM == SP)
		res = STACK[SP];
	else /* SPM1 */
		res = STACK[SP-1];
	if (SP == 0)
		CTRL.UNDERFLOW = 1;
	if (CONFIG.READ_POP_ENABLE)
		SP--;

The CTRL register is used to manually push/pop the stack and check its status:

MMIO 0x001384: CTRL [NV41:NV50]
MMIO 0x619e44: CTRL [NV50-]
  bit 0: INCSP_TRIGGER - when written as 1, increments SP by 1. Always reads
         as 0.
  bit 1: DECSP_TRIGGER - like above, except it decrements SP by 1.
  bit 4: EMPTY - read-only, reads as 1 when SP == 0.
  bit 5: FULL - read-only, reads as 1 when SP >= 0x200.
  bit 6: OVERFLOW - read-only, the sticky overflow error bit
  bit 7: UNDERFLOW - read-only, the sticky underflow error bit

To configure the stack, the CONFIG register is used:

MMIO 0x001388: CONFIG [NV41:NV50]
MMIO 0x619e48: CONFIG [NV50-]
  bit 0: WRITE_PUSH_ENABLE - if 1, writes to VAL increment SP [see above]
  bit 1: READ_POP_ENABLE - if 1, reads from VAL decrement SP [see above]
  bit 2: READ_FROM - selects which cell is read by VAL, one of:
    0: SP - VAL reads from STACK[SP]
    1: SPM1 - VAL reads from STACK[SP-1]
  bit 6: OVERFLOW_CLEAR - when written as 1, clears CTRL.OVERFLOW to 0.
    Always reads as 0.
  bit 7: UNDERFLOW_CLEAR - like above, for CTRL.UNDERFLOW

MMIO 0x00138c: SP [NV41:NV50]
MMIO 0x619e4c: SP [NV50-]
  The stack pointer. Only low 10 bits are valid.
