#!/usr/bin/python
import subprocess
import sys
import os
import bisect
from lxml import etree as ET

colon = "39584ac56e6d0976692778b80915f94b61767814a8704982"

def hexa(v):
	if v <= 9:
		return str(v)
	else:
		return hex(v)

tree = ET.parse("rules.xml")
root = tree.getroot();
outdir = "rules"
try:
	os.mkdir(outdir)
except:
	pass
try:
	os.mkdir(outdir + "/mmio")
except:
	pass
try:
	os.mkdir(outdir + "/objects")
except:
	pass

devices_by_name = {}
devices_by_offset = []
device_offsets = []
devices = []

class Device(object):
	pass

def create_device(device):
	assert device.tag == "device"
	name = device.attrib["name"]
	if name in devices_by_name:
		into = devices_by_name[name]
		for elem in device.iterchildren(tag=ET.Element):
			device.remove(elem)
			into.device.append(elem)
		if int(device.attrib["start"], 0) != into.offset and not into.baddup:
			print "Unknown bad duplicate device: " + name
	else:
		dev = Device()
		dev.device = device
		dev.offset = int(device.attrib["start"], 0)
		dev.end = int(device.attrib["end"], 0) + 1
		dev.stride = dev.end - dev.offset
		dev.rnn_name = dev.name = name
		dev.members = []
		devices_by_name[dev.name] = dev
		devices_by_offset.append((dev.offset, dev))
		dev.field_values = []
		dev.baddup = False
		# these are duplicated with different values: manually set the right ones
		if dev.name == "NV_PVIDEO":
			dev.offset = 0x8000
			dev.end = 0x9000
			dev.baddup = True
		elif dev.name in ("NV_064", "NV_065", "NV_066"):
			size = dev.end - dev.offset
			dev.offset = int(dev.name[3:], 16) << 16
			dev.end = dev.offset + size
			dev.baddup = True

for device in root.iterchildren(tag=ET.Element):
	create_device(device)

addendum = '<rule-database><device name="NV_PRMIO" start="0x00007100" end="0x0000710f" /></rule-database>'
for device in ET.fromstring(addendum).iterchildren(tag=ET.Element):
	create_device(device)

devices_by_offset.sort()
device_offsets = [offset for offset, device in devices_by_offset]
devices = [device for offset, device in devices_by_offset]

def common_prefix_len(a, b):
	i = 0
	while a[i:i+1] == b[i:i+1]:
		i += 1
	return i

def lookup_address(address, name):
	cand_devices = [(-common_prefix_len(device.name, name), device) for device in devices if address >= device.offset and address < device.end]
	cand_devices.sort()

	device = cand_devices[0][1]
	assert address >= device.offset
	assert address < device.offset + device.stride

	return (device, address - device.offset)

# these seem to be broken: ignore for now
ignored = set(("NV_VIO", "NV_CIO", "NV_UREMAP", "NV_PREMAP"))

field_name_to_type_map = {"HANDLE" : "object", "STYLE" : "notify_style"}
uninteresting_field_names = ["VAL", "VALUE", "PARAMETER", "ADDRESS", "RESERVED", "DATA", "BLAH", "COUNT", "CNT", "ARGUMENT", "BITMAP", "OFFSET", "FIELD", "MODE", "LE"]
uninteresting_field_names += field_name_to_type_map.keys()
uninteresting_field_names = frozenset(uninteresting_field_names)

# SET_NOTIFY is duplicated by NOTIFY
# TODO: put *all* the standard ones there, including NOTIFY, probably
uninteresting_reglike_names = frozenset(["NOP", "NOTIFY", "SET_NOTIFY", "CTX_SWITCH"])

# from renouveau.xml
# the rules.xml names suck
known_objclasses = {
	0x0001 : "NV01_ROOT",
	0x0002 : "NV01_CONTEXT_DMA",
	0x0003 : "NV01_DEVICE",
	0x0004 : "NV01_TIMER",
	0x0012 : "NV01_CONTEXT_BETA1",
	0x0017 : "NV01_CONTEXT_COLOR_KEY",
	0x0057 : "NV04_CONTEXT_COLOR_KEY",
	0x0018 : "NV01_CONTEXT_PATTERN",
	0x0019 : "NV01_CONTEXT_CLIP_RECTANGLE",
	0x001c : "NV01_RENDER_SOLID_LINE",
	0x005c : "NV04_RENDER_SOLID_LINE",
	0x001d : "NV01_RENDER_SOLID_TRIANGLE",
	0x005d : "NV04_RENDER_SOLID_TRIANGLE",
	0x001e : "NV01_RENDER_SOLID_RECTANGLE",
	0x005e : "NV04_RENDER_SOLID_RECTANGLE",
	0x001f : "NV01_IMAGE_BLIT",
	0x005f : "NV04_IMAGE_BLIT",
	0x009f : "NV12_IMAGE_BLIT",
	0x0021 : "NV01_IMAGE_FROM_CPU",
	0x0061 : "NV04_IMAGE_FROM_CPU",
	0x0065 : "NV05_IMAGE_FROM_CPU",
	0x008a : "NV10_IMAGE_FROM_CPU",
	0x038a : "NV30_IMAGE_FROM_CPU",
	0x308a : "NV40_IMAGE_FROM_CPU",
	0x0030 : "NV01_NULL",
	0x0036 : "NV03_STRETCHED_IMAGE_FROM_CPU",
	0x0076 : "NV04_STRETCHED_IMAGE_FROM_CPU",
	0x0066 : "NV05_STRETCHED_IMAGE_FROM_CPU",
	0x0366 : "NV30_STRETCHED_IMAGE_FROM_CPU",
	0x3066 : "NV40_STRETCHED_IMAGE_FROM_CPU",
	0x0037 : "NV03_SCALED_IMAGE_FROM_MEMORY",
	0x0077 : "NV04_SCALED_IMAGE_FROM_MEMORY",
	0x0063 : "NV05_SCALED_IMAGE_FROM_MEMORY",
	0x0089 : "NV10_SCALED_IMAGE_FROM_MEMORY",
	0x0389 : "NV30_SCALED_IMAGE_FROM_MEMORY",
	0x3089 : "NV40_SCALED_IMAGE_FROM_MEMORY",
	0x0038 : "NV04_DVD_SUBPICTURE",
	0x0088 : "NV10_DVD_SUBPICTURE",
	0x0039 : "NV04_MEMORY_TO_MEMORY_FORMAT",
	0x5039 : "NV50_MEMORY_TO_MEMORY_FORMAT",
	0x003d : "NV01_MEMORY_LOCAL_BANKED",
#	0x003e : "NV01_MAPPING_SYSTEM",
	0x003f : "NV03_MEMORY_LOCAL_CURSOR",
	0x0040 : "NV01_MEMORY_LOCAL_LINEAR",
	0x0041 : "NV01_MAPPING_LOCAL",
	0x0042 : "NV04_CONTEXT_SURFACES_2D",
	0x0062 : "NV10_CONTEXT_SURFACES_2D",
	0x0362 : "NV30_CONTEXT_SURFACES_2D",
	0x3062 : "NV40_CONTEXT_SURFACES_2D",
	0x0043 : "NV03_CONTEXT_ROP",
	0x0044 : "NV04_IMAGE_PATTERN",
	0x0046 : "NV03_VIDEO_LUT_CURSOR_DAC",
	0x0048 : "NV03_TEXTURED_TRIANGLE",
	0x004a : "NV04_GDI_RECTANGLE_TEXT",
	0x004b : "NV03_GDI_RECTANGLE_TEXT",
	0x0052 : "NV04_SWIZZLED_SURFACE",
	0x009e : "NV20_SWIZZLED_SURFACE",
	0x039e : "NV30_SWIZZLED_SURFACE",
	0x309e : "NV40_SWIZZLED_SURFACE",
	0x0053 : "NV04_CONTEXT_SURFACES_3D",
	0x0093 : "NV10_CONTEXT_SURFACES_3D",
	0x0054 : "NV04_TEXTURED_TRIANGLE",
	0x0094 : "NV10_TEXTURED_TRIANGLE",
	0x0055 : "NV04_MULTITEX_TRIANGLE",
	0x0095 : "NV10_MULTITEX_TRIANGLE",
	0x0056 : "NV10TCL",
	0x0096 : "NV11TCL",
	0x0099 : "NV17TCL",
	0x0058 : "NV03_CONTEXT_SURFACES_2D",
	0x005a : "NV03_CONTEXT_SURFACES_3D",
	0x0060 : "NV04_INDEXED_IMAGE_FROM_CPU",
	0x0064 : "NV05_INDEXED_IMAGE_FROM_CPU",
	0x006a : "NV03_CHANNEL_PIO",
	0x006b : "NV03_CHANNEL_DMA",
	0x0072 : "NV04_BETA_SOLID",
	0x007b : "NV10_TEXTURE_FROM_CPU",
	0x037b : "NV30_TEXTURE_FROM_CPU",
	0x307b : "NV40_TEXTURE_FROM_CPU",
	0x007c : "NV10_VIDEO_DISPLAY",
	0x0097 : "NV20TCL",
	0x0597 : "NV25TCL",
	0x0397 : "NV30TCL",
	0x0497 : "NV35TCL",
	0x0697 : "NV34TCL",
	0x4097 : "NV40TCL",
	0x4497 : "NV44TCL",
	0x502d : "NV50_2D",
	0x5097 : "NV50TCL",
	0x8297 : "NV84TCL",
	0x8397 : "NVA0TCL",
	0x8597 : "NVA8TCL",
	0x50c0 : "NV50_COMPUTE",
	0x0010 : "NV_IMAGE_STENCIL",
	0x0011 : "NV_IMAGE_BLEND_AND",
	0x0013 : "NV_IMAGE_ROP_AND",
	0x0015 : "NV_IMAGE_COLOR_KEY",
	0x0064 : "NV01_IMAGE_SRCCOPY_AND",
	0x0065 : "NV03_IMAGE_SRCCOPY",
	0x0066 : "NV04_IMAGE_SRCCOPY_PREMULT",
	0x0067 : "NV04_IMAGE_BLEND_PREMULT",
}

def process_values(field, rnn_field):
	true_value = None
	false_value = None
	common_prefix = None

	rnn_values = []
	strong_bool = False

	for field_value in field.iterchildren(tag=ET.Element):
		if field_value.tag == "field-value":
			field_value_name = field_value.attrib["name"]
			rnn_value_name = field_value_name
			if rnn_value_name.startswith(field_name + "_"):
				rnn_value_name = field_value_name[len(field_name)+1:]
			rnn_value = ET.Element("value")
			rnn_value.attrib["name"] = rnn_value_name
			rnn_value.attrib["value"] = hexa(int(field_value.attrib["value"], 0))
			rnn_values.append(rnn_value)
			rnn_field.append(rnn_value)
			if rnn_value_name in ("FALSE", "OFF", "DISABLE", "DISABLED", "NO", "0"):
				false_value = rnn_value
				if rnn_value_name != "0":
					strong_bool = True
			if rnn_value_name in ("TRUE", "ON", "ENABLE", "ENABLED", "YES", "1"):
				true_value = rnn_value
				if rnn_value_name != "0":
					strong_bool = True

	# avoid reglikes with just "0 = 0"
	if len(rnn_values) == 1 and rnn_values[0].attrib["name"] == "0" and rnn_values[0].attrib["value"] == "0":
		rnn_field.remove(rnn_values[0])
		rnn_values = []
	elif len(rnn_values) and len(rnn_values) == ((1 if true_value is not None else 0) + (1 if false_value is not None else 0)):
		if false_value is not None:
			rnn_field.remove(false_value)
		if true_value is not None:
			rnn_field.remove(true_value)
		rnn_field.attrib["type"] = "boolean"

	if len(rnn_values) > 1 and rnn_field.attrib["name"] not in ("NOTIFY",):
		for rnn_value in rnn_values:
			rnn_value_name = rnn_value.attrib["name"]
			if rnn_value_name == "INVALID" or rnn_value_name[0:1].isdigit():
				pass
			elif common_prefix is None:
				common_prefix = rnn_value_name
			else:
				common_prefix = common_prefix[:common_prefix_len(common_prefix, rnn_value_name)]

	if common_prefix:
		us = common_prefix.rfind("_")
		if us >= 0:
			common_prefix = common_prefix[:us + 1]
			if common_prefix:
				for rnn_value in rnn_values:
					if rnn_value.attrib["name"].startswith(common_prefix):
						rnn_value.attrib["name"] = rnn_value.attrib["name"][len(common_prefix):]
				rnn_field.attrib["name"] += "_" + common_prefix.rstrip("_")

#print ET.tostring(tree)
for orig_device in devices_by_name.values():
	for reglike in orig_device.device.iterchildren(tag=ET.Element):
		if reglike.tag == "register" or reglike.tag == "array":
			ok = True
			for i in ignored:
				if reglike.attrib["name"].startswith(i):
					ok = False
					break
			if not ok:
				continue
			(device, offset) = lookup_address(int(reglike.attrib["address"], 0), reglike.attrib.get("name", ""))
			reglike_name = reglike.attrib["name"]
			rnn_reglike_name = reglike_name
			if rnn_reglike_name.startswith(device.name + "_"):
				rnn_reglike_name = rnn_reglike_name[len(device.name) + 1:]
			else:
				pass # TODO

			if rnn_reglike_name in uninteresting_reglike_names:
				continue

			rnn_reglike = ET.Element("reg32")
			device.members.append((offset, rnn_reglike))

			rnn_reglike.attrib["offset"] = hex(offset)

			if reglike.tag == "array":
				max_size = 0
				for field in reglike.iterchildren(tag=ET.Element):
					if field.tag == "array-size":
						size = int(field.attrib["size"], 0)
						if size > max_size:
							max_size = size
				rnn_reglike.attrib["length"] = str(max_size)
				rnn_reglike.attrib["stride"] = str(int(reglike.attrib["width"], 0))

			num_bitfields = 0
			full_field_name = None
			for field in reglike.iterchildren(tag=ET.Element):
				if field.tag == "field":
					i = 0 # for "i" variables in the low-bit and high-bit attributes
					low = eval(field.attrib["low-bit"])
					high = eval(field.attrib["high-bit"])
					field_name = field.attrib["name"]
					rnn_field_name = field_name
					if rnn_field_name.startswith(reglike_name + "_"):
						rnn_field_name = rnn_field_name[len(reglike_name)+1:]
					# yes, rules.xml does actually have "BLAH" fields
					# TODO: these should set the type
					if low == 0 and high == 31:
						if rnn_field_name not in uninteresting_field_names and not rnn_field_name.startswith("NV_"):
							full_field_name = rnn_field_name
						if rnn_field_name in field_name_to_type_map:
							rnn_reglike.attrib["type"] = field_name_to_type_map[rnn_field_name]
						bitfield = rnn_reglike
						for elem in field.iterchildren(tag=ET.Element):
							field.remove(elem)
							reglike.append(elem)
					else:
						bitfield = ET.Element("bitfield")
						rnn_reglike.append(bitfield)
						bitfield.attrib["low"] = str(low)
						bitfield.attrib["high"] = str(high)
						bitfield.attrib["name"] = rnn_field_name
						num_bitfields += 1
						process_values(field, bitfield)

			if full_field_name is not None and num_bitfields == 0:
				rnn_reglike_name += "_" + full_field_name
			rnn_reglike.attrib["name"] = rnn_reglike_name
			process_values(reglike, rnn_reglike)

		elif reglike.tag == "field-value":
			orig_device.field_values.append(reglike)

for device in devices_by_name.values():
	if not device.members:
		continue
	device.members.sort()
	stripe = ET.Element("stripe")
	objclasses = {}

	for field_value in device.field_values:
		if "name" in field_value.attrib and "value" in field_value.attrib:
			if not objclasses:
				device.rnn_name = field_value.attrib["name"]
				device.objclass = int(field_value.attrib["value"], 0)
			objclasses[int(field_value.attrib["value"], 0)] = field_value.attrib["name"]

	for objclass in objclasses:
		if objclass in known_objclasses:
			objclasses[objclass] = known_objclasses[objclass]

	objclasses = objclasses.items()
	objclasses.sort()

	if device.rnn_name == "NV_UTOMEM":
		device.rnn_name = "NV_IMAGE_TO_MEMORY"
		objclasses = [("", device.rnn_name)]

	database = ET.Element("database")
	database.attrib["xmlns"] = "http://nouveau.freedesktop.org/"
	database.attrib["xmlns" + colon + "xsi"] = "http://www.w3.org/2001/XMLSchema-instance"
	database.attrib["xsi" + colon + "schemaLocation"] = "http://nouveau.freedesktop.org/ rules-ng.xsd"

	for offset, member in device.members:
		if objclasses and offset == 0:
			if "value" in member.attrib:
				objclasses[int(member.attrib["value"], 0)] = member.attrib["name"]
		else:
			stripe.append(member)

	if objclasses:
		objenum = ET.Element("enum")
		objenum.attrib["bare"] = "yes"
		objenum.attrib["name"] = "obj-class"

		for objclass, objname in objclasses:
			objvalue = ET.Element("value")
			if objclass is not "":
				objvalue.attrib["value"] = hex(objclass)
			objvalue.attrib["name"] = objname
			objenum.append(objvalue)

		database.append(objenum)

		subchan = ET.Element("domain")
		subchan.attrib["name"] = "NV01_SUBCHAN"
		subchan.attrib["bare"] = "yes"
		subchan.attrib["size"] = "0x2000"
		assert device.stride == 0x2000

		stripe.attrib["prefix"] = "obj-class"
		#stripe.attrib["varset"] = "obj-class"
		if len(objclasses) == 1:
			stripe.attrib["variants"] = objclasses[0][1]
		else:
			stripe.attrib["variants"] = objclasses[0][1] + "-" + objclasses[-1][1]
		subchan.append(stripe)
		database.append(subchan)
	else:
		mmio = ET.Element("domain")
		mmio.attrib["name"] = "NV_MMIO"
		mmio.attrib["bare"] = "yes"
		mmio.attrib["prefix"] = "chipset"

		stripe.attrib["name"] = device.rnn_name
		stripe.attrib["offset"] = hex(device.offset)
		stripe.attrib["stride"] = hex(device.stride)
		mmio.append(stripe)
		database.append(mmio)

	basename = device.rnn_name
	if basename.startswith("NV_"):
		basename = basename[3:]
	basename = basename.lower()
	filename = outdir + "/" + ("objects" if objclasses else "mmio") + "/" + basename

	outfile = open(filename, "w")
	xml2text = subprocess.Popen("./xml2text", stdin = subprocess.PIPE, stdout = outfile)
	xml2text.communicate(ET.tostring(database).replace(colon, ":"))
	xml2text.wait()
	outfile.close()

