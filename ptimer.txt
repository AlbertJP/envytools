Introduction

PTIMER is a small functional unit used to measure time by the card. It has
a 56-bit tick counter connected to a programmable clock source. The current
value of this counter is used for timestamping by many other units on the GPU.
Two such timestamps can be substracted to get the wall time elapsed between
their creation and measure eg. command execution time. Also, it's possible to
set up an interrupt that will be triggered when the low 27 bits of the counter
reach a specified value.

The PTIMER's MMIO range is 0x9000:0xa000. It is enabled by PMC.ENABLE bit 16,
and its interrupt line is connected to PMC.INTR line 20. It's available on all
cards, starting with nv01.

Curiously, on NV41+ the PTIMER is also used to report MMIO faults, ie. MMIO
space accesses from host that failed for some reason.


MMIO register list

* means a NV41+ only register
# means a register available only on [XXX: check which chipsets]

009060# ???		???
009064# ???		???
009080# ???		???
[XXX: figure these out]
009084* MMIO_FAULT_ADDR	address and type of last MMIO fault
009088* MMIO_FAULT_DATA	data written on last MMIO fault
[XXX: document these]
009100  INTR		interrupt status / acknowledge
009140  INTR_EN		interrupt enable
009200  NUMERATOR	clock multiplier
009210  DENOMINATOR	clock divider
009220* CLOCK_SOURCE	clock source selection
009400  TIME_LOW	low part of the time counter
009410  TIME_HIGH	high part of the time counter
009420  ALARM		the TIME_LOW value to interrupt on


The time counter

PTIMER's clock is a 64-bit value that is spread across two 32-bit registers:

 - TIME_LOW: The lower part of PTIMER's clock
 - TIME_HIGH: The higher part of PTIMER's clock

PTIMER's clock source depends on chipset families:

 - nv03 family: MPLL (memory PLL)
 - nv04:nv41: Core PLL
 - nv41+: A programmable clock set to 27MHz by default

On nv03-nv40 chipsets, ptimer's clock is divided by a configurable divider stage.
The resulting clock frequency is given by (where NUMERATOR > DENOMINATOR):

  clock = clock_source * PTIMER.DENOMINATOR / PTIMER.NUMERATOR

On nv41-nvc0, clock source is not bound anymore to the core or the memory PLL.
Instead clock source is by default set to 27MHz but can be divided or increased
up to around 100MHz. Bit 16 of CLOCK_SOURCE overrides this modulation and
sets the clock source at its maximum value. If bit 16 is clear, clock source is
given by the equation:

  clock_source = 27 * (1 + CLOCK_SOURCE.DENOMINATOR) / (1 + CLOCK_SOURCE.NUMERATOR)

[XXX: Check clock source consistency across boards]

Registers are:

0x9100: PTIMER.INTR
  bit 0: ALARM
  Status of the interruptions generated by PTIMER.

0x9140: PTIMER.INTR_EN
  bit 0: ALARM
  Interruptions enable bitfield. Set to enable, clear to disable.

0x9200: PTIMER.NUMERATOR
  A 16-bit register.

0x9210: PTIMER.DENOMINATOR
  A 16bit register.

0x9220: PTIMER.CLOCK_SOURCE
  bits 0-7: DENOMINATOR
  bits 12-8: NUMERATOR
  bit 16: MAX_FREQUENCY [XXX: seems to be 100MHz and 108MHz on nvc0+]
  Nv40+'s clock source configuration register.

0x9400: PTIMER.TIME_0
  The lower 32 bits of PTIMER's clock.

0x9410: PTIMER.TIME_1
  The highest 32 bits of PTIMER's clock.

0x9410: PTIMER.ALARM_0
  A 32-bit register that, when equal to PTIMER.TIME_0, generates the ALARM interrupt:
  if (ALARM == TIME_0) INTR |= 1


Reading the clock

In order to accurately read the clock, the following code should be used:

uint32 high1, high2, low;

do
{
	high1 = iord(TIME_HIGH);
	low = iord(TIME_LOW);
	high2 = iord(TIME_HIGH);
} while (high1 != high2);

This code works around the "mutual dependency". No matter in what order the
registers are read, an issue may arise and lead to an error of 2^32 as show by
the following examples:

 - TIME_LOW is read, overflows and then TIME_HIGH is read
 - TIME_HIGH is read, TIME_LOW overflows, TIME_LOW is read

The proposed code checks no overflow on TIME_LOW happened between the moment we
read TIME_HIGH and the moment we read TIME_HIGH again. If it happened, we start
again until it succeeds.
