Introduction

Some operations in GPUs are time sensitive. These operations can range from very
low-level (enforcing memory timings) to high-level (monitoring execution time).

This need lead nVidia to write PTIMER, an engine dedicated to time tracking.

PTIMER's clock is a 64-bit value that is spread across two 32-bit registers:

 - TIME_LOW: The lower part of PTIMER's clock
 - TIME_HIGH: The higher part of PTIMER's clock

PTIMER's clock source depends on chipset families:

 - nv03 family: MPLL (memory PLL)
 - nv04-40 families: Core PLL
 - nv40-C0 family: A 27MHz crystal

On nv03-nv40 chipsets, ptimer's clock is divided by a configurable divider stage.
The resulting clock frequency is given by (where NUMERATOR > DENOMINATOR):

  clock = clock_source * PTIMER.DENOMINATOR / PTIMER.NUMERATOR

On nv40-nvc0, clock source is not bound anymore to the core or the memory PLL.
Instead clock source is by default set to 27MHz but can be divided or increased
up to around 100MHz. Bit 16 of CLOCK_SOURCE overrides this modulation and
sets the clock source at its maximum value. If bit 16 is clear, clock source is
given by the equation:

  clock_source = 27 * (1 + CLOCK_SOURCE.DENOMINATOR) / (1 + CLOCK_SOURCE.NUMERATOR)

[XXX: Check the clock source consistency across boards]

Registers are:

0x9100: PTIMER.INTR
  bit 0: ALARM
  Status of the interruptions generated by PTIMER.

0x9140: PTIMER.INTR_EN
  bit 0: ALARM
  Interruptions enable bitfield. Set to enable, clear to disable.

0x9200: PTIMER.NUMERATOR
  A 16-bit register.

0x9210: PTIMER.DENOMINATOR
  A 16bit register.

0x9220: PTIMER.CLOCK_SOURCE
  bits 0-7: DENOMINATOR
  bits 12-8: NUMERATOR
  bit 16: MAX_FREQUENCY [XXX: seems to be 100MHz and 108MHz on nvc0+]
  Nv40+'s clock source configuration register.

0x9400: PTIMER.TIME_0
  The lower 32 bits of PTIMER's clock.

0x9410: PTIMER.TIME_1
  The highest 32 bits of PTIMER's clock.

0x9410: PTIMER.ALARM_0
  A 32-bit register that, when equal to PTIMER.TIME_0, generates the ALARM interrupt:
  if (ALARM == TIME_0) INTR |= 1


Reading the clock

In order to accurately read the clock, the following code should be used:

uint32 high1, high2, low;

do
{
	high1 = iord(TIME_HIGH);
	low = iord(TIME_LOW);
	high2 = iord(TIME_HIGH);
} while (high1 != high2);

This code works around the "mutual dependency". No matter in what order the
registers are read, an issue may arise and lead to an error of 2^32 as show by
the following examples:

 - TIME_LOW is read, overflows and then TIME_HIGH is read
 - TIME_HIGH is read, TIME_LOW overflows, TIME_LOW is read

The proposed code checks no overflow on TIME_LOW happened between the moment we
read TIME_HIGH and the moment we read TIME_HIGH again. If it happened, we start
again until it succeeds.
