Instructions

0. Conventions
1. MOV
2. Integer ADD family
3. Integer short MUL
4. Bit operations

0. Conventions

  S(x): 31th bit of x for 32-bit x, 15th for 16-bit x.
  SEX(x): sign-extension of x
  ZEX(x): zero-extension of x

1. MOV

  [lanemask] mov b32/b16 DST SRC

  lanemask assumed 0xf for short and immediate versions.

	if (lanemask & 1 << (laneid & 3)) DST = SRC;

  Short:	0x10000000 base opcode
  		0x00008000 0: b16, 1: b32
		operands: S*DST, S*SRC1/S*SHARED

  Imm:		0x10000000 base opcode
  		0x00008000 0: b16, 1: b32
		operands: L*DST, IMM

  Long:		0x10000000 0x00000000 base opcode
  		0x00000000 0x04000000 0: b16, 1: b32
  		0x00000000 0x0003c000 lanemask
		operands: LL*DST, L*SRC1/L*SHARED

2. Integer ADD family

  add [sat] b32/b16 [CDST] DST SRC1 SRC2		O2=0, O1=0
  sub [sat] b32/b16 [CDST] DST SRC1 SRC2		O2=0, O1=1
  subr [sat] b32/b16 [CDST] DST SRC1 SRC2		O2=1, O1=0
  addc [sat] b32/b16 [CDST] DST SRC1 SRC2 COND		O2=1, O1=1

  All operands are 32-bit or 16-bit according to size specifier.

	b16/b32 s1, s2;
	bool c;
	switch (OP) {
		case add: s1 = SRC1, s2 = SRC2, c = 0; break;
		case sub: s1 = SRC1, s2 = ~SRC2, c = 1; break;
		case subr: s1 = ~SRC1, s2 = SRC2, c = 1; break;
		case addc: s1 = SRC1, s2 = SRC2, c = COND.C; break;
	}
	res = s1+s2+c;	// infinite precision
	CDST.C = res >> (b32 ? 32 : 16);
	res = res & (b32 ? 0xffffffff : 0xffff);
	CDST.O = (S(s1) == S(s2)) && (S(s1) != S(res));
	if (sat && CDST.O)
		if (S(res)) res = (b32 ? 0x7fffffff : 0x7fff);
		else res = (b32 ? 0x80000000 : 0x8000);
	CDST.S = S(res);
	CDST.Z = res == 0;
	DST = res;

  Short/imm:	0x20000000 base opcode
		0x10000000 O2 bit
		0x00400000 O1 bit
		0x00008000 0: b16, 1: b32
		0x00000100 sat flag
		operands: S*DST, S*SRC1/S*SHARED, S*SRC2/S*CONST/IMM, $c0

  Long:		0x20000000 0x00000000 base opcode
		0x10000000 0x00000000 O2 bit
		0x00400000 0x00000000 O1 bit
		0x00000000 0x04000000 0: b16, 1: b32
		0x00000000 0x08000000 sat flag
		operands: MCDST, LL*DST, L*SRC1/L*SHARED, L*SRC3/L*CONST3, COND

3. Integer short MUL

  mul [CDST] DST u16/s16 SRC1 u16/s16 SRC2

  DST is 32-bit, SRC1 and SRC2 are 16-bit.

	b32 s1, s2;
	if (src1_signed)
		s1 = SEX(SRC1);
	else
		s1 = ZEX(SRC1);
	if (src2_signed)
		s2 = SEX(SRC2);
	else
		s2 = ZEX(SRC2);
	b32 res = s1*s2;	// modulo 2^32
	CDST.O = 0;
	CDST.C = 0;
	CDST.S = S(res);
	CDST.Z = res == 0;
	DST = res;

  Short/imm:	0x40000000 base opcode
  		0x00008000 src1 is signed
  		0x00000100 src2 is signed
  		operands: SDST, SHSRC/SHSHARED, SHSRC2/SHCONST/IMM

  Long:		0x40000000 0x00000000 base opcode
  		0x00000000 0x00008000 src1 is signed
  		0x00000000 0x00004000 src2 is signed
  		operands: MCDST, LDST, LHSRC1/LHSHARED, LHSRC2/LHCONST2

4. Bit operations

  and b32/b16 DST [not] SRC1 [not] SRC2		O2=0, O1=0
  or b32/b16 DST [not] SRC1 [not] SRC2		O2=0, O1=1
  xor b32/b16 DST [not] SRC1 [not] SRC2		O2=1, O1=0
  mov2 b32/b16 DST [not] SRC1 [not] SRC2	O2=1, O1=1

  Immediate forms only allows 32-bit operands, and cannot negate second op.

	s1 = (not1 ? ~SRC1 : SRC1);
	s2 = (not2 ? ~SRC2 : SRC2);
	switch (OP) {
		case and: res = s1 & s2; break;
		case or: res = s1 | s2; break;
		case xor: res = s1 ^ s2; break;
		case mov2: res = s2; break;
	}
	CDST.O = 0;
	CDST.C = 0;
	CDST.S = S(res);
	CDST.Z = res == 0;
	DST = res;

  Imm:		0xd0000000 base opcode
		0x00400000 not1
		0x00008000 O2 bit
		0x00000100 O1 bit
		operands: SDST, SSRC/SSHARED, IMM

  Long:		0xd0000000 0x00000000 base opcode
		0x00000000 0x04000000 0: b16, 1: b32
		0x00000000 0x00020000 not2
		0x00000000 0x00010000 not1
		0x00000000 0x00008000 O2 bit
		0x00000000 0x00004000 O1 bit
		operands: MCDST, LL*DST, L*SRC1/L*SHARED, L*SRC2/L*CONST2
