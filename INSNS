Instructions

0. Conventions
1. MOV
2. Special regs
 2.1. MOV from $c
 2.2. MOV to $c
 2.3. MOV from $a
 2.4. SHL to $a
 2.5. ADD from $a to $a
 2.6. MOV from sreg
3. Integer ADD family
4. Integer short MUL
5. Integer 24-bit MUL
6. Integer SAD
7. Bit operations

0. Conventions

  S(x): 31th bit of x for 32-bit x, 15th for 16-bit x.
  SEX(x): sign-extension of x
  ZEX(x): zero-extension of x

1. Normal MOV

  [lanemask] mov b32/b16 DST SRC

  lanemask assumed 0xf for short and immediate versions.

	if (lanemask & 1 << (laneid & 3)) DST = SRC;

  Short:	0x10000000 base opcode
  		0x00008000 0: b16, 1: b32
		operands: S*DST, S*SRC1/S*SHARED

  Imm:		0x10000000 base opcode
  		0x00008000 0: b16, 1: b32
		operands: L*DST, IMM

  Long:		0x10000000 0x00000000 base opcode
  		0x00000000 0x04000000 0: b16, 1: b32
  		0x00000000 0x0003c000 lanemask
		operands: LL*DST, L*SRC1/L*SHARED

2.1. MOV from $c

  mov DST COND

  DST is 32-bit $r.

	DST = COND;

  Long:		0x00000000 0x20000000 base opcode
  		operands: LDST, COND

2.2. MOV to $c

  mov CDST SRC

  SRC is 32-bit $r. Yes, the 0x40 $c write enable flag in second word is
  actually ignored.

	CDST = SRC;

  Long:		0x00000000 0xa0000000 base opcode
  		operands: CDST, LSRC1

2.3. MOV from $a

  mov DST AREG

  DST is 32-bit $r. Setting flag normally used for autoincrement mode doesn't
  work, but still causes crash when using non-writable $a's.

	DST = AREG;

  Long:		0x00000000 0x40000000 base opcode
  		0x02000000 0x00000000 crashy flag
  		operands: LDST, AREG

2.4. SHL to $a

  shl ADST SRC SHCNT

  SRC is 32-bit $r.

	ADST = SRC << SHCNT;

  Long:		0x00000000 0xc0000000 base opcode
  		operands: ADST, LSRC1/LSHARED, HSHCNT

2.5. ADD from $a to $a

  add ADST AREG OFFS

  Like mov from $a, setting flag normally used for autoincrement mode doesn't
  work, but still causes crash when using non-writable $a's.

	ADST = AREG + OFFS;

  Long:		0xd0000000 0x20000000 base opcode
  		0x02000000 0x00000000 crashy flag
  		operands: ADST, AREG, OFFS

2.6. MOV from sreg

  mov DST physid	S=0
  mov DST clock		S=1
  mov DST sreg2		S=2
  mov DST sreg3		S=3
  mov DST pm0		S=4
  mov DST pm1		S=5
  mov DST pm2		S=6
  mov DST pm3		S=7

  DST is 32-bit $r.

	DST = SREG;

  Long:		0x00000000 0x60000000 base opcode
  		0x00000000 0x0001c000 S
  		operands: LDST

3. Integer ADD family

  add [sat] b32/b16 [CDST] DST SRC1 SRC2		O2=0, O1=0
  sub [sat] b32/b16 [CDST] DST SRC1 SRC2		O2=0, O1=1
  subr [sat] b32/b16 [CDST] DST SRC1 SRC2		O2=1, O1=0
  addc [sat] b32/b16 [CDST] DST SRC1 SRC2 COND		O2=1, O1=1

  All operands are 32-bit or 16-bit according to size specifier.

	b16/b32 s1, s2;
	bool c;
	switch (OP) {
		case add: s1 = SRC1, s2 = SRC2, c = 0; break;
		case sub: s1 = SRC1, s2 = ~SRC2, c = 1; break;
		case subr: s1 = ~SRC1, s2 = SRC2, c = 1; break;
		case addc: s1 = SRC1, s2 = SRC2, c = COND.C; break;
	}
	res = s1+s2+c;	// infinite precision
	CDST.C = res >> (b32 ? 32 : 16);
	res = res & (b32 ? 0xffffffff : 0xffff);
	CDST.O = (S(s1) == S(s2)) && (S(s1) != S(res));
	if (sat && CDST.O)
		if (S(res)) res = (b32 ? 0x7fffffff : 0x7fff);
		else res = (b32 ? 0x80000000 : 0x8000);
	CDST.S = S(res);
	CDST.Z = res == 0;
	DST = res;

  Short/imm:	0x20000000 base opcode
		0x10000000 O2 bit
		0x00400000 O1 bit
		0x00008000 0: b16, 1: b32
		0x00000100 sat flag
		operands: S*DST, S*SRC1/S*SHARED, S*SRC2/S*CONST/IMM, $c0

  Long:		0x20000000 0x00000000 base opcode
		0x10000000 0x00000000 O2 bit
		0x00400000 0x00000000 O1 bit
		0x00000000 0x04000000 0: b16, 1: b32
		0x00000000 0x08000000 sat flag
		operands: MCDST, LL*DST, L*SRC1/L*SHARED, L*SRC3/L*CONST3, COND

4. Integer short MUL

  mul [CDST] DST u16/s16 SRC1 u16/s16 SRC2

  DST is 32-bit, SRC1 and SRC2 are 16-bit.

	b32 s1, s2;
	if (src1_signed)
		s1 = SEX(SRC1);
	else
		s1 = ZEX(SRC1);
	if (src2_signed)
		s2 = SEX(SRC2);
	else
		s2 = ZEX(SRC2);
	b32 res = s1*s2;	// modulo 2^32
	CDST.O = 0;
	CDST.C = 0;
	CDST.S = S(res);
	CDST.Z = res == 0;
	DST = res;

  Short/imm:	0x40000000 base opcode
  		0x00008000 src1 is signed
  		0x00000100 src2 is signed
  		operands: SDST, SHSRC/SHSHARED, SHSRC2/SHCONST/IMM

  Long:		0x40000000 0x00000000 base opcode
  		0x00000000 0x00008000 src1 is signed
  		0x00000000 0x00004000 src2 is signed
  		operands: MCDST, LLDST, LHSRC1/LHSHARED, LHSRC2/LHCONST2

5. Integer 24-bit MUL

  mul [CDST] DST [high] u24/s24 SRC1 SRC2

  All operands are 32-bit.

	b48 s1, s2;
	if (signed) {
		s1 = SEX((b24)SRC1);
		s2 = SEX((b24)SRC2);
	} else {
		s1 = ZEX((b24)SRC1);
		s2 = ZEX((b24)SRC2);
	}
	b48 m = s1*s2;	// modulo 2^48
	b32 res = (high ? m >> 16 : m & 0xffffffff);
	CDST.O = 0;
	CDST.C = 0;
	CDST.S = S(res);
	CDST.Z = res == 0;
	DST = res;

  Short/imm:	0x40000000 base opcode
  		0x00008000 src are signed
  		0x00000100 high
  		operands: SDST, SSRC/SSHARED, SSRC2/SCONST/IMM

  Long:		0x40000000 0x00000000 base opcode
  		0x00000000 0x00008000 src are signed
  		0x00000000 0x00004000 high
  		operands: MCDST, LLDST, LSRC1/LSHARED, LSRC2/LCONST2

6. Integer SAD

  sad [CDST] DST u/s HSRC1 HSRC2 SRC3		b16
  sad [CDST] DST u/s SRC1 SRC2 SRC3		b32

  Short variant is restricted to DST same as SRC3.

	int s1, s2; // infinite precision
	if (signed) {
		s1 = SEX(SRC1);
		s2 = SEX(SRC2);
	} else {
		s1 = ZEX(SRC1);
		s2 = ZEX(SRC2);
	}
	b32 mres = abs(s1-s2);	// modulo 2^32
	res = mres+s3;		// infinite precision
	CDST.C = res >> (b32 ? 32 : 16);
	res = res & (b32 ? 0xffffffff : 0xffff);
	CDST.O = (S(mres) == S(s3)) && (S(mres) != S(res));
	CDST.S = S(res);
	CDST.Z = res == 0;
	DST = res;

  Short:	0x50000000 base opcode
  		0x00008000 0: b16 1: b32
		0x00000100 src are signed
		operands: DST, SDST, S*SRC/S*SHARED, S*SRC2/S*CONST, SDST

  Long:		0x50000000 0x00000000 base opcode
		0x00000000 0x04000000 0: b16, 1: b32
  		0x00000000 0x08000000 src sre signed
		operands: MCDST, LLDST, L*SRC1/L*SHARED, L*SRC2/L*CONST2, L*SRC3/L*CONST3

7. Bit operations

  and b32/b16 [CDST] DST [not] SRC1 [not] SRC2		O2=0, O1=0
  or b32/b16 [CDST] DST [not] SRC1 [not] SRC2		O2=0, O1=1
  xor b32/b16 [CDST] DST [not] SRC1 [not] SRC2		O2=1, O1=0
  mov2 b32/b16 [CDST] DST [not] SRC1 [not] SRC2	O2=1, O1=1

  Immediate forms only allows 32-bit operands, and cannot negate second op.

	s1 = (not1 ? ~SRC1 : SRC1);
	s2 = (not2 ? ~SRC2 : SRC2);
	switch (OP) {
		case and: res = s1 & s2; break;
		case or: res = s1 | s2; break;
		case xor: res = s1 ^ s2; break;
		case mov2: res = s2; break;
	}
	CDST.O = 0;
	CDST.C = 0;
	CDST.S = S(res);
	CDST.Z = res == 0;
	DST = res;

  Imm:		0xd0000000 base opcode
		0x00400000 not1
		0x00008000 O2 bit
		0x00000100 O1 bit
		operands: SDST, SSRC/SSHARED, IMM
		assumed: not2=0 and b32.

  Long:		0xd0000000 0x00000000 base opcode
		0x00000000 0x04000000 0: b16, 1: b32
		0x00000000 0x00020000 not2
		0x00000000 0x00010000 not1
		0x00000000 0x00008000 O2 bit
		0x00000000 0x00004000 O1 bit
		operands: MCDST, LL*DST, L*SRC1/L*SHARED, L*SRC2/L*CONST2
