<?xml version="1.0" encoding="UTF-8"?>
<database xmlns="http://nouveau.freedesktop.org/"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://nouveau.freedesktop.org/ rules-ng.xsd">
<import file="copyright.xml"/>

<import file="nvchipsets.xml" />
<import file="nv50_defs.xml" />

<enum name="NV50_PGRAPH_DATA_ERROR">
	<value value="3" name="INVALID_QUERY_OR_TEXTURE">
		<brief>You used invalid param to QUERY_GET method. Or you
		used a TIC/TSC entry over TIC/TSC limit. Weird.</brief>
	</value>
	<value value="4" name="INVALID_VALUE">
		<brief>You used too big / too small / unaligned value.</brief>
	</value>
	<value value="5" name="INVALID_ENUM">
		<brief>Invalid value for an enum bitfield/register.</brief>
	</value>
	<value value="8" name="INVALID_OBJECT">
		<brief>You used object of invalid class as param to one of 0x180-0x1fc methods.</brief>
	</value>
	<value value="9" name="READ_ONLY_OBJECT">
		<brief>You used read-only DMA object for a write-only DMA slot.</brief>
	</value>
	<value value="0xa" name="SUPERVISOR_OBJECT">
		<brief>You tried to bind a DMA object with the SUPERVISOR flag set.</brief>
	</value>
	<value value="0xb" name="INVALID_ADDRESS_ALIGNMENT">
		<brief>One of your addresses is unaligned.</brief>
		<doc>Usually, unaligned addresses trigger INVALID_VALUE
		immediately on the address method. However, sometimes
		[m2mf for example] the required alignment depends on other
		state, and cannot be checked immediately. In this case, you
		instead get this error when you actually try to launch
		something.</doc>
	</value>
	<value value="0xc" name="INVALID_BITFIELD">
		<brief>You had non-0 value in bits not corresponding to any bitfield.</brief>
	</value>
	<value value="0xd" name="BEGIN_END_ACTIVE">
		<brief>You tried changing stuff while begin/end was active.</brief>
	</value>
	<value value="0xe" name="SEMANTIC_COLOR_BACK_OVER_LIMIT">
		<brief>You tried to use a back color slot out of range of VP/GP outputs.</brief>
	</value>
	<value value="0xf" name="VIEWPORT_ID_NEEDS_GP">
		<brief>You tried to enable VIEWPORT_ID without enabling GP.</brief>
	</value>
	<value value="0x10" name="RT_DOUBLE_BIND">
		<brief>You bound more than one set of FP outputs to given RT index.</brief>
	</value>
	<value value="0x11" name="RT_TYPES_MISMATCH">
		<brief>You tried to use tiled and linear RTs simultanously.</brief>
	</value>
	<value value="0x12" name="RT_LINEAR_WITH_ZETA">
		<brief>You tried to use linear RTs with ZETA enabled.</brief>
	</value>
	<value value="0x15" name="FP_TOO_FEW_REGS">
		<brief>You allocated too few registers in FP to cover all outputs.</brief>
	</value>
	<value value="0x16" name="ZETA_FORMAT_CSAA_MISMATCH">
		<brief>You tried to use CSAA with non-CSAA ZETA format, or the other way around.</brief>
	</value>
	<value value="0x17" name="RT_LINEAR_WITH_MSAA">
		<brief>You tried to use linear RTs with MSAA/CSAA enabled.</brief>
	</value>
	<value value="0x18" name="FP_INTERPOLANT_START_OVER_LIMIT">
		<brief>You tried to use a slot out of range of VP/GP outputs for FP interpolant start.</brief>
	</value>
	<value value="0x19" name="SEMANTIC_LAYER_OVER_LIMIT">
		<brief>You tried to use a layer slot out of range of VP/GP outputs.</brief>
	</value>
	<value value="0x1a" name="RT_INVALID_ALIGNMENT">
		<brief>You tried to use tiled RT without 0x100-byte alignment.</brief>
	</value>
	<value value="0x1b" name="SAMPLER_OVER_LIMIT">
		<brief>You tried to BIND_TSC a sampler not defined by TEX_LIMITS.</brief>
	</value>
	<value value="0x1c" name="TEXTURE_OVER_LIMIT">
		<brief>You tried to BIND_TIC a texture not defined by TEX_LIMITS.</brief>
	</value>
	<value value="0x1e" name="GP_TOO_MANY_OUTPUTS">
		<brief>You tried to reserve more GP output space than the MP has available.</brief>
	</value>
	<value value="0x1f" name="RT_BPP128_WITH_MS8">
		<brief>You tried to use 8xMSAA with 128bpp RT.</brief>
	</value>
	<value value="0x21" name="Z_OUT_OF_BOUNDS"> <!-- m2mf at least. 2d too? -->
		<brief>Your z coord exceeds the depth of your surface.</brief>
	</value>
	<value value="0x23" name="XY_OUT_OF_BOUNDS"> <!-- m2mf at least. 2d too? -->
		<brief>Your x/y coords exceed the size of your surface.</brief>
	</value>
	<value value="0x27" name="CP_MORE_PARAMS_THAN_SHARED">
		<brief>You tried to launch block with more params than allocated s[] space.</brief>
	</value>
	<value value="0x28" name="CP_NO_REG_SPACE_STRIPED">
		<brief>You tried to use too much registers per block, and it didn't fit, with striped reg mode.</brief>
	</value>
	<value value="0x29" name="CP_NO_REG_SPACE_PACKED">
		<brief>You tried to use too much registers per block, and it didn't fit, with packed reg mode.</brief>
	</value>
	<value value="0x2a" name="CP_NOT_ENOUGH_WARPS">
		<brief>Your block requires more warps than MP can handle.</brief>
	</value>
	<value value="0x2b" name="CP_BLOCK_SIZE_MISMATCH">
		<brief>The XYZ dimensions of block you specified indicate a smaller block than BLOCK_ALLOC implies.</brief>
	</value>
	<value value="0x2c" name="CP_NOT_ENOUGH_LOCAL_WARPS">
		<brief>Your block requires more warps than LOCAL_WARPS allows..</brief>
	</value>
	<value value="0x2d" name="CP_NOT_ENOUGH_STACK_WARPS">
		<brief>Your block requires more warps than STACK_WARPS allows.</brief>
	</value>
	<value value="0x2e" name="CP_NO_BLOCKDIM_LATCH">
		<brief>Your didn't use BLOCKDIM_LATCH between block dimension setup and kernel launch.</brief>
	</value>
	<value value="0x31" name="ENG2D_FORMAT_MISMATCH"> <!-- sifc at least. -->
		<brief>The dst/src format combination you chose doesn't make sense.</brief>
	</value>
	<value value="0x3f" name="PRIMITIVE_ID_NEEDS_GP">
		<brief>You tried to enable PRIMITIVE_ID without enabling GP.</brief>
	</value>
	<value value="0x44" name="SEMANTIC_VIEWPORT_OVER_LIMIT">
		<brief>You tried to use a viewport index slot out of range of VP/GP outputs.</brief>
	</value>
	<value value="0x45" name="SEMANTIC_COLOR_FRONT_OVER_LIMIT">
		<brief>You tried to use a front color slot out of range of VP/GP outputs.</brief>
	</value>
	<value value="0x46" name="LAYER_ID_NEEDS_GP">
		<brief>You tried to enable LAYER_ID without enabling GP.</brief>
	</value>
	<value value="0x47" name="SEMANTIC_CLIP_OVER_LIMIT">
		<brief>You tried to use a clip distance slot out of range of VP/GP outputs.</brief>
	</value>
	<value value="0x48" name="SEMANTIC_PTSZ_OVER_LIMIT">
		<brief>You tried to use a point size slot out of range of VP/GP outputs.</brief>
	</value>
</enum>

<domain name="NV_MMIO" bare="yes" prefix="chipset">
<array name="PGRAPH" offset="0x400000" stride="0x10000" length="1" variants="NV50:NVC0">
	<reg32 offset="0x0040" name="DISABLE">
		<brief>Disable / reset subunits</brief>
		<doc>Writing 1 to a bit disables given subunit, causes it to disappear from MMIO,
		and [at least sometimes] resets its state.
		
		ctxprog opcode 90XXXX ors low 16 bits of this register with XXXX, 91XXXX ors high
		16 bits of this register with XXXX. CMD 9 resets this register to 0.

		Trying to launch a ctxprog xfer touching a disabled subunit is a bad idea.
		</doc>
		<bitfield name="DISPATCH" pos="0" /> <!-- 8XX, 54XX+ [or 48XX+], 6FFX, force STATUS 1. NV50 strand 0. NVA0 strand 0. -->
		<bitfield name="M2MF" pos="1" /> <!-- 68XX. NV50 strand 0. NVA0 strand 0. -->
		<bitfield name="VFETCH" pos="2" /> <!-- CXX, NV50 strand 1. NVA0 strand 3. -->
		<bitfield name="CCACHE" pos="3" /> <!-- 50XX, NV50 strand 2. NVA0 strand 4. -->
		<bitfield name="UNK10XX" pos="6" /> <!-- NV50 strand 2. NVA0 strand 1. -->
		<bitfield name="STRMOUT" pos="7" /> <!-- 18XX, NV50 strand 2. NVA0 strand 0. -->
		<bitfield name="UNK14XX" pos="8" /> <!-- and 15XX, NV50 strand 2. NVA0 strand 7 / 2. -->
		<bitfield name="UNK8CXX" pos="9" /> <!-- 8CXX / 80XX, NV50 strand 4. NVA0 strand 6 -->
		<bitfield name="TPROP" pos="10" /> <!-- 8EXX / 87XX, NV50 strand 4. NVA0 strand 6 -->
		<bitfield name="TEXTURE" pos="11" /> <!-- 88XX, 89XX, 8AXX / 85XX, 86XX, NV50 strand 4. NVA0 strand 6 -->
		<bitfield name="UNK84XX" pos="12" /> <!-- NV50 strand 4. NVA0 strand 6. -->
		<bitfield name="MP" pos="13" /> <!-- 82XX, 83XX / 81XX, 82XX, 83XX, NV50 xfer2. NVA0 xfer2 -->
		<bitfield name="UNK24XX" pos="14" /> <!-- NV50 strand 0. NVA0 strand 2. huge. -->
		<bitfield name="CSCHED" pos="15" /> <!-- force STATUS 2001 and some other stuff, NV50 strand 1 and xfer2. NVA0 strand 0 and xfer2. -->
		<bitfield name="UNK1CXX" pos="16" /> <!-- NV50 strand 2. NVA0 strand 0. -->
		<bitfield name="CLIPID" pos="17" /> <!-- NV50 strand 0. NVA0 strand 6 -->
		<bitfield name="ZCULL" pos="18" /> <!-- NV50 strand 0. NVA0 strand 6 -->
		<bitfield name="ENG2D" pos="19" /> <!-- NV50 strand 1. NVA0 strand 6 -->
		<bitfield name="UNK34XX" pos="20" /> <!-- NV50 strand 2. NVA0 strand 0. -->
		<bitfield name="ROP" pos="21" /> <!-- 7xxx, NV50 strands 1 and 3. NVA0 strand 5. -->
	</reg32>
	<reg32 offset="0x0060" name="UNK60" />
	<reg32 offset="0x0080" name="DEBUG_0">
		<bitfield pos="4" name="INVALID_OBJECT_CHECK"/>
		<bitfield pos="6" name="INVALID_STATE_CHECK"/>
		<bitfield pos="7" name="INVALID_COMMAND_CHECK"/> <!-- also INVALID_ENUM, INVALID_QUERY_OR_TEXTURE, ILLEGAL_MTHD, ILLEGAL_CLASS, BEGIN_END_ACTIVE -->
		<bitfield pos="8" name="INVALID_BITFIELD_CHECK"/>
		<bitfield pos="9" name="UNK9"/> <!-- makes COMPUTE not work for some reason. -->
	</reg32>
	<reg32 offset="0x0088" name="DEBUG_2"/>
	<reg32 offset="0x008c" name="DEBUG_3">
		<bitfield name="HW_CONTEXT_SWITCH" pos="2" />
		<bitfield name="SINGLE_STEP" pos="8" />
	</reg32>
	<reg32 offset="0x0100" name="INTR">
		<brief>Interrupt status</brief>
		<doc>Shows currently pending interrupts. Write 1 to a bit to reset it, and ACK the interrupt.</doc>
		<bitfield name="NOTIFY" pos="0">
			<doc>You asked for a NOTIFY with interrupt and got it.</doc>
		</bitfield>
		<bitfield name="QUERY" pos="1">
			<doc>You asked for a QUERY with interrupt and got it.</doc>
		</bitfield>
		<bitfield name="SYNC" pos="2">
			<doc>You sent a sync QUERY command and it triggered.</doc>
		</bitfield>
		<bitfield name="ILLEGAL_MTHD" pos="4">
			<doc>You tried to use a method that doesn't exist on this class.</doc>
		</bitfield>
		<bitfield name="ILLEGAL_CLASS" pos="5">
			<doc>You tried to use a class not supported by this GPU.</doc>
		</bitfield>
		<bitfield name="DOUBLE_NOTIFY" pos="6">
			<doc>You tried to use NOTIFY command on another NOTIFY command.</doc>
		</bitfield>
		<bitfield name="CONTEXT_SWITCH" pos="12">
			<doc>PGRAPH needs a context switch, and automatic context switches are disabled.</doc>
		</bitfield>
		<bitfield name="BUFFER_NOTIFY" pos="16">
			<doc>You asked for m2mf transfer with interrupt after finish and got it.</doc>
		</bitfield>
		<bitfield name="DATA_ERROR" pos="20">
			<doc>You used an invalid parameter for this method. Or maybe you tried
			to launch some operation, but the relevant state is inconsistent.
			Relevant state is in DATA_ERROR</doc>
		</bitfield>
		<bitfield name="TRAP" pos="21">
			<doc>A PGRAPH command failed in the middle of execution. TRAP register will
			tell you which subunit reports the trap.</doc>
		</bitfield>
		<bitfield name="UNK22" pos="22" />
		<bitfield name="SINGLE_STEP" pos="24" />
		<bitfield name="CTXPROG_PAUSED" pos="25">
			<doc>Can be triggered by pausing ctxprog via CTXCTL_CONTROL... but that's
			useless, there should be another way to trigger it.</doc>
		</bitfield>
	</reg32>
	<reg32 offset="0x0108" name="TRAP">
		<brief>Trap status</brief>
		<doc>Like INTR, but applies to TRAP sub-types. Shows which subunits report trap.
		Each subunit has its own TRAP status register, which you have to check in turn
		to know the exact TRAP sub-subtype, and reset it. Write 1 to a bit to reset it
		and ACK the trap.
		
		If a bit applies to a per-TP subunit, you need to check all TPs to see which one
		is reporting the trap.</doc>
		<bitfield name="DISPATCH" pos="0">
			<brief>Check 400804</brief>
		</bitfield>
		<bitfield name="M2MF" pos="1">
			<brief>Check 406800</brief>
		</bitfield>
		<bitfield name="VFETCH" pos="2">
			<brief>Check 400c04</brief>
		</bitfield>
		<bitfield name="STRMOUT" pos="3">
			<brief>Check 401800</brief>
		</bitfield>
		<bitfield name="CCACHE" pos="4">
			<brief>Check 405018</brief>
		</bitfield>
		<bitfield name="CLIPID" pos="5">
			<brief>Check 402000</brief>
		</bitfield>
		<bitfield name="TEXTURE" pos="6">
			<brief>Check TP+0x900 / TP+0x600</brief>
		</bitfield>
		<bitfield name="MP" pos="7">
			<brief>Check TP+0x314 / TP+0x31c</brief>
		</bitfield>
		<bitfield name="TPROP" pos="8">
			<brief>Check TP+0xe08 / TP+0x708</brief>
		</bitfield>
	</reg32>
	<reg32 offset="0x0110" name="DATA_ERROR" type="NV50_PGRAPH_DATA_ERROR">
		<doc>Stores type of the pending DATA_ERROR.</doc>
	</reg32>
	<reg32 offset="0x0138" name="TRAP_EN">
		<brief>Trap enable</brief>
		<doc>A bitmask of events that will cause traps, same bit assignments as in TRAP reg.</doc>
		<bitfield name="DISPATCH" pos="0" />
		<bitfield name="M2MF" pos="1" />
		<bitfield name="VFETCH" pos="2" />
		<bitfield name="STRMOUT" pos="3" />
		<bitfield name="CCACHE" pos="4" />
		<bitfield name="CLIPID" pos="5" />
		<bitfield name="TEXTURE" pos="6" />
		<bitfield name="MP" pos="7" />
		<bitfield name="TPROP" pos="8" />
	</reg32>
	<reg32 offset="0x013c" name="INTR_EN">
		<brief>Interrupt enable</brief>
		<doc>A bitmask of events that will cause interrupts, same bit assignments as in INTR reg.</doc>
		<bitfield name="NOTIFY" pos="0" />
		<bitfield name="QUERY" pos="1" />
		<bitfield name="SYNC" pos="2" />
		<bitfield name="ILLEGAL_MTHD" pos="4" />
		<bitfield name="ILLEGAL_CLASS" pos="5" />
		<bitfield name="DOUBLE_NOTIFY" pos="6" />
		<bitfield name="CONTEXT_SWITCH" pos="12" />
		<bitfield name="BUFFER_NOTIFY" pos="16" />
		<bitfield name="DATA_ERROR" pos="20" />
		<bitfield name="TRAP" pos="21" />
		<bitfield name="UNK22" pos="22" />
		<bitfield name="SINGLE_STEP" pos="24" />
		<bitfield name="CTXPROG_PAUSED" pos="25" />
	</reg32>

	<reg32 offset="0x0200" name="ICMD_CMD" />
	<reg32 offset="0x0204" name="ICMD_DATA" />

	<reg32 offset="0x0300" name="CTXCTL_STATUS">
		<brief>ctxprog status</brief>
		<!-- TODO: Figure this out.-->
		<bitfield name="RUNNING" pos="0" />
		<bitfield name="DISPATCH_FREE" pos="1" />
		<!-- bits 2 and 3 light up when PC == 0... wtf? -->
		<bitfield name="PAUSED" pos="4" />
		<bitfield name="NEXTDIFFERS" pos="8" /> <!-- CUR != NEXT -->
	</reg32>
	<reg32 offset="0x0304" name="CTXCTL_CONTROL">
		<bitfield name="RUN" pos="0" />
		<bitfield name="CONT" pos="1" />
		<bitfield name="PAUSE" pos="4" />
	</reg32>
	<reg32 offset="0x0308" name="CTXCTL_OPCODE">
 		<doc>Next opcode to execute, or the exit opcode if program exitted.</doc>
	</reg32>
	<reg32 offset="0x030c" name="CTXCTL_PC_RD" access="r">
 		<doc>RO alias of PC for some reason</doc>
	</reg32>
	<reg32 offset="0x0310" name="CTXCTL_PC">
 		<doc>Program Counter. Readable and writable. In units of single insns.</doc>
	</reg32>
	<reg32 offset="0x031c" name="CTXCTL_SCRATCH">
 		<doc>ctxprog scratch register, holding params to various opcodes/CMDs. Written by opcode 2XXXXX.</doc>
	</reg32>
	<reg32 offset="0x0320" name="CTXCTL_CMD" access="w">
		<doc>CMD register. Writing here launches a given CMD.</doc>
		<value value="0x4" name="NEWCTXDMA" />
		<value value="0x5" name="NEXT_TO_SWAP" />
		<value value="0x6" name="SET_REG_POINTER" />
		<value value="0x7" name="SET_XFER_POINTER" />
		<value value="0x8" name="DELAY" /> <!-- light up flag 0x4c after SCRATCH cycles [for a single cycle only!] -->
		<value value="0x9" name="ENABLE" />
		<value value="0xa" name="UNK0A" />
		<value value="0xb" name="UNK0B" />
		<value value="0xc" name="END" />
		<value value="0xd" name="NEXT_TO_CURRENT" />
		<value value="0xf" name="UNK0F" /> <!-- causes 101 in STATUS, 200 in FLAGS_2 -->
		<value value="0x11" name="UNK11" />
		<value value="0x12" name="UNK12" /> <!-- causes some new registers to appear / light up. fun. -->
		<value value="0x16" name="UNK16" />
	</reg32>
	<reg32 offset="0x0324" name="CTXCTL_INDEX" access="w">
		<doc>Code upload index. Selects address to write in ctxprog code, counted in insns.</doc>
	</reg32>
	<reg32 offset="0x0328" name="CTXCTL_DATA" access="w">
		<doc>Code upload. Writes given insn to code storage and autoincrements upload index.</doc>
	</reg32>
	<reg32 offset="0x032c" name="CTXCTL_CUR">
		<doc>Current channel.</doc>
		<bitfield name="CHAN" high="29" low="0" type="nv50_channel"/>
		<bitfield name="VALID" pos="31"/>
	</reg32>
	<reg32 offset="0x0330" name="CTXCTL_NEXT">
		<doc>Next channel: the one that PFIFO wants us to switch to.</doc>
		<bitfield name="CHAN" high="29" low="0" type="nv50_channel"/>
		<bitfield name="VALID" pos="31"/>
	</reg32>
	<reg32 offset="0x0334" name="CTXCTL_PTR_REG">
		<doc>Offset in grctx to read/write with opcode 1XXXXX. In units of 32-bit words.</doc>
	</reg32>
	<reg32 offset="0x0338" name="CTXCTL_SCRATCH2">
		<doc>Some register, set with opcode 3XXXXX. No known use on NV50, on NVA0 selects
		which TP to read/write via 1XXXXX opcode. Maybe generic MMIO offset? Or really offsets
		all TPs even on non-ctxprog accesses?</doc> <!-- TODO -->
	</reg32>
	<reg32 offset="0x033c" name="CTXCTL_PTR_XFER">
		<doc>Offset in grctx to read/write with opcode 8XXXXX. In units of 32-bit words.</doc>
	</reg32>

	<!-- blob checks these on 100c80... -->
	<reg32 offset="0x0380" name="UNK380"/>
	<reg32 offset="0x0384" name="UNK384"/>
	<reg32 offset="0x0388" name="UNK388"/>

	<stripe offset="0x0400" name="STRAND">
		<reg32 offset="0x00" name="BUSY" access="r"/>
		<reg32 offset="0x04" name="CTRL">
			<bitfield low="0" high="4" name="CNT"/>
			<bitfield low="8" high="10" name="STRAND_IDX"/>
			<bitfield pos="12" name="AREA_SELECT"/>
			<bitfield pos="14" name="UNK14"/>
			<bitfield pos="15" name="UNK15"/>
			<bitfield pos="16" name="DIR">
				<value value="0" name="READ"/>
				<value value="1" name="WRITE"/>
			</bitfield>
			<bitfield pos="17" name="TRIGGER"/>
		</reg32>
		<reg32 offset="0x08" name="ADDR">
			<bitfield low="0" high="11" name="SUBIDX"/>
			<bitfield low="12" high="15" name="UNK12"/>
			<bitfield low="16" high="29" name="SEEKPOINT"/>
		</reg32>
		<reg32 offset="0x20" name="DATA" length="20"/>
	</stripe>
	
	<stripe offset="0x0500" name="FIFO">
		<brief>pre-DISPATCH FIFO control</brief>
		<doc>This pair of registers deals with PGRAPH's method FIFO.
		PFIFO pushes methods here, DISPATCH pulls them out and
		executes. The FIFO itself is buried inside DISPATCH's context
		strand, and contains 8 [NV50] or 0x100 [NV84+] repetitions of
		method + subchannel + inc/noninc + single/double + data1
		+ data2 + 1 unknown bit. DISPATCH_CMD will pull the last
		method from the FIFO whenever it's free and FIFO contains
		stuff.
		</doc>
		<reg32 offset="0x00" name="CONTROL">
			<bitfield pos="0" name="PULL">
				<doc>Enables executing commands incoming through DISPATCH_CMD.</doc>
			</bitfield>
			<bitfield pos="8" name="UNK8"/>
			<bitfield pos="16" name="UNK16"/> <!-- usually set, but doesn't seem needed for operation... -->
			<bitfield high="28" low="20" name="LIMIT" variants="NV84-">
				<doc>Max number of slots allowed to be occupied in FIFO. 0 and > 0x100 are treated as 0x100.</doc>
			</bitfield>
		</reg32>
		<reg32 offset="0x04" name="STATUS" access="r">
			<bitfield pos="0" name="EMPTY" />
			<bitfield pos="1" name="FULL" />
			<bitfield high="7" low="4" name="OCCUPIED" variants="NV50">
				<doc>How many slots contain valid data atm.</doc>
			</bitfield>
			<bitfield high="11" low="8" name="GET" variants="NV50" />
			<bitfield high="19" low="16" name="PUT" variants="NV50" />
			<bitfield high="15" low="4" name="OCCUPIED" variants="NV84-">
				<doc>How many slots contain valid data atm.</doc>
			</bitfield>
			<bitfield high="23" low="16" name="GET" variants="NV84-" />
			<bitfield high="31" low="24" name="PUT" variants="NV84-" />
		</reg32>
	</stripe>

	<reg32 offset="0x0700" name="STATUS" access="r">
		<doc>Shows which parts of PGRAPH are currently busy with doing some stuff. 1 means busy, 0 means idle.</doc>
		<bitfield name="ALL" pos="0">
			<doc>Is 1 if anything at all is busy.</doc>
		</bitfield>
		<bitfield name="DISPATCH" pos="1"/>
		<bitfield name="M2MF" pos="6"/>
		<bitfield name="CTXPROG" pos="8"/>
		<bitfield name="VFETCH" pos="9"/>
		<bitfield name="CCACHE" pos="10"/>
		<bitfield name="STRMOUT" pos="11"/>
		<bitfield name="CSCHED" pos="13"/>
		<bitfield name="UNK1CXX" pos="14"/>
		<bitfield name="CLIPID" pos="15"/>
		<bitfield name="ZCULL" pos="16"/>
		<bitfield name="ENG2D" pos="17"/>
		<bitfield name="UNK34XX" pos="18"/>
		<bitfield name="UNK8CXX" pos="19"/>
		<bitfield name="TPROP" pos="20"/>
		<bitfield name="TEX" pos="21"/>
		<bitfield name="UNK84XX" pos="22"/>
		<bitfield name="MP" pos="23"/>
		<bitfield name="ROP" pos="24"/>
	</reg32>
	<reg32 offset="0x0704" name="TRAPPED_ADDR">
		<doc>Offending subchan + method, for [most types of] PGRAPH interrupts.</doc>
		<bitfield name="MTHD" high="12" low="2" shr="2" />
		<bitfield name="SUBCH" high="18" low="16" />
		<bitfield name="UNK28" pos="24" />
		<bitfield name="UNK" pos="31" />
	</reg32>
	<reg32 offset="0x0708" name="TRAPPED_DATA_LOW">
		<doc>Offending method data, for [most types of] PGRAPH interrupts.</doc>
	</reg32>
	<reg32 offset="0x070c" name="TRAPPED_DATA_HIGH" /> <!-- I have no idea what this is for. But it's been around since NV10. -->
	<reg32 offset="0x0748" name="UNK748" />
	<reg32 offset="0x0784" name="CTXCTL_SWAP" type="nv50_channel">
		<doc>Channel whose grctx is read/written by ctxprog opcodes 1XXXXX, 8XXXXX.</doc>
	</reg32>

	<reg32 offset="0x0804" name="DISPATCH_TRAP">
		<bitfield name="FAULT" pos="0" /> <!-- COND/NOTIFIER faults at least. check 800848? -->
		<bitfield name="QUERY" pos="1" /> <!-- hmm... -->
		<bitfield name="GRCTX_FAULT_MMIO" pos="2" />
		<bitfield name="GRCTX_FAULT_XFER1" pos="3" />
		<bitfield name="GRCTX_FAULT_XFER2" pos="4" />
		<bitfield name="CLEAR" pos="30" />
		<bitfield name="ENABLE" pos="31" />
	</reg32>
	<reg32 offset="0x0808" name="DISPATCH_CMD_ADDR">
		<bitfield name="MTHD" high="12" low="2" shr="2" />
		<bitfield name="SUBCH" high="18" low="16" />
		<bitfield name="NONINCR" pos="20" />
		<bitfield name="UNK1" pos="21" /> <!-- sometimes set by DISPATCH itself during exec... related to NOTIFY? -->
		<bitfield name="SINGLE_STEP_DONE" pos="22" />
		<bitfield name="UNK3" high="24" low="23" />
		<bitfield name="DOUBLE" pos="25" />
		<bitfield name="UNK2" pos="28" />
		<bitfield name="CURRENT_SUBCH" pos="29" />
		<bitfield name="VALID" pos="31" />
	</reg32>
	<reg32 offset="0x080c" name="DISPATCH_CMD_DATA_LOW" />
	<reg32 offset="0x0810" name="DISPATCH_CMD_DATA_HIGH" />
	<reg32 offset="0x0814" name="CTX_SWITCH_1">
		<bitfield name="CLASS" high="15" low="0"/>
		<bitfield name="COLOR_KEY" pos="16"/>
		<bitfield name="USER_CLIP" pos="17"/>
		<bitfield name="UNK19" high="31" low="19" />
	</reg32>
	<reg32 offset="0x0818" name="CTX_SWITCH_2">
		<bitfield name="NOTIFY_INSTANCE" high="15" low="0"/>
		<bitfield name="UNK24" high="31" low="24" />
	</reg32>
	<reg32 offset="0x081c" name="CTX_SWITCH_3">
		<bitfield name="DMA_INSTANCE" high="15" low="0">
			<doc>Only used for sifm, gdirect, m2mf.</doc>
		</bitfield>
		<bitfield name="ENDIAN" pos="24">
			<value value="0" name="LITTLE" />
			<value value="1" name="BIG" />
		</bitfield>
		<bitfield name="SINGLE_STEP" pos="26" />
	</reg32>
	<reg32 offset="0x0820" name="CTX_SWITCH_4">
		<bitfield name="MY_INSTANCE" high="31" low="16"/>
		<bitfield name="COND_INSTANCE" high="15" low="0">
			<doc>Also second DMA slot on m2mf.</doc>
		</bitfield>
	</reg32>
	<reg32 offset="0x0824" name="CTXCTL_FLAGS_0">
		<bitfield name="SWAP_DIRECTION" pos="0">
			<value value="0" name="LOAD" />
			<value value="1" name="SAVE" />
		</bitfield>
		<bitfield name="UNK1" pos="1"/> <!-- set while loading/saving context... -->
		<bitfield name="DISPATCH_DROP" pos="3"/> <!-- causes incoming methods to get ignored, haven't dug deeper yet. -->
		<bitfield name="XFER_ENABLE" pos="14"/> <!-- xfer just hangs when attempted without this bit set. -->
		<bitfield name="UNK1D" pos="29"/> <!-- set while saving context... -->
	</reg32>
	<reg32 offset="0x0828" name="CTXCTL_FLAGS_1"> <!-- saved to context -->
		<bitfield name="UNK0" pos="0"/> <!-- weird stuff happens when not set -->
	</reg32>
	<reg32 offset="0x082c" name="CTXCTL_FLAGS_2">
		<bitfield name="IDLE" pos="0" />
		<bitfield name="UNK1" pos="1" /> <!-- usually 1, but seen 0 on NVA5.. -->
		<bitfield name="AUTO_SAVE" pos="4" />
		<bitfield name="AUTO_LOAD" pos="5" />
		<bitfield name="UNK9" pos="9" /> <!-- seems to indicate some sort of ctxprog error. or maybe busy condition. you're in deep shit if this is 1 for you. -->
		<bitfield name="NEWCTX_DONE" pos="10" /> <!-- extraordinarly weird. seems to blink "1" only for a very short amount of time. you need the wait right after the cmd. -->
		<bitfield name="XFER_BUSY" pos="11" />
		<bitfield name="DELAY_DONE" pos="12" />
		<bitfield name="ALWAYS_TRUE" pos="13" />
		<bitfield name="INTR_PENDING" pos="15" />
	</reg32>
	<reg32 offset="0x0830" name="CTXCTL_FLAGS_3">
	</reg32>

	<reg32 offset="0x0844" name="DISPATCH_UNK844">
		<bitfield name="UNK0" pos="0" />
		<bitfield name="SUBCH" high="15" low="13" />
		<bitfield name="UNK31" pos="31" />
	</reg32>
	<reg32 offset="0x0848" name="DISPATCH_MISC">
		<bitfield name="NOTIFY_FAULT" pos="0" />
		<bitfield name="COND_FAULT" pos="3" />
		<bitfield name="NOTIFY_PENDING" pos="8" />
		<bitfield name="NOTIFY_AWAKEN" pos="16" />
	</reg32>
	<reg32 offset="0x084c" name="DISPATCH_ST2_ADDR">
		<doc>Second stage of dispatch... if QUERY blows up on you,
		it can get stuck here. At least sometimes.</doc>
		<bitfield name="MTHD" high="12" low="2" shr="2" />
		<bitfield name="UNK28" pos="28" />
		<bitfield name="ILLEGAL_CLASS" pos="29" />
		<bitfield name="ILLEGAL_MTHD" pos="30" />
		<bitfield name="VALID" pos="31" />
	</reg32>

	<reg32 offset="0x085c" name="DISPATCH_ST2_DATA_LOW" />
	<reg32 offset="0x0860" name="DISPATCH_ST2_DATA_HIGH" />

	<reg32 offset="0x0868" name="DISPATCH_ST2_DATA_ERROR">
		<bitfield high="15" low="0" name="TYPE" type="NV50_PGRAPH_DATA_ERROR" />
		<bitfield pos="16" name="VALID" />
	</reg32>
	<reg32 offset="0x086c" name="DISPATCH_ST3_ADDR">
		<bitfield name="MTHD" high="12" low="2" shr="2" />
		<bitfield name="UNK28" pos="28" />
		<bitfield name="VALID" pos="31" />
	</reg32>
	<reg32 offset="0x0874" name="DISPATCH_ST3_DATA_LOW" />
	<reg32 offset="0x0878" name="DISPATCH_ST3_DATA_HIGH" />
	<reg32 offset="0x087c" name="DISPATCH_ST4_DATA_ERROR">
		<bitfield high="15" low="0" name="TYPE" type="NV50_PGRAPH_DATA_ERROR" />
		<bitfield pos="31" name="VALID" />
	</reg32>

	<reg32 offset="0x0884" name="DISPATCH_ST5_ADDR">
		<bitfield high="17" low="0" name="INDEX" />
		<bitfield high="21" low="20" name="UNK1" />
		<bitfield pos="31" name="VALID" />

	</reg32>
	<reg32 offset="0x0888" name="DISPATCH_ST5_DATA" />

	<reg32 offset="0x0898" name="DISPATCH_ST6_DATA" />
	<reg32 offset="0x089c" name="DISPATCH_ST6_ADDR" />

	<reg32 offset="0x08dc" name="COND_ADDRESS_HIGH">
		<bitfield name="3D" high="7" low="0" />
		<bitfield name="2D" high="15" low="8" />
	</reg32>
	<reg32 offset="0x08e0" name="COND_ADDRESS_LOW_3D" />
	<reg32 offset="0x08e4" name="COND_ADDRESS_LOW_2D" />
	<reg32 offset="0x08e8" name="COND">
		<bitfield name="3D" pos="0" />
		<bitfield name="2D" pos="1" />
		<bitfield name="UNK6" pos="6" /> <!-- COND traps cause this to be set. being set seems to prevent context switching and generally wreak havoc... -->
	</reg32>

	<reg32 offset="0x08f8" name="CLOCK" />
	<reg32 offset="0x08fc" name="UNITS">
		<bitfield name="TP_MASK" high="15" low="0" />
		<bitfield name="ROPC_MASK" high="21" low="16" variants="NV50:NVA0" />
		<bitfield name="MP_MASK" high="23" low="22" variants="NV50:NVA0" />
		<bitfield name="ROPC_MASK" high="23" low="16" variants="NVA0-" />
		<bitfield name="MP_MASK" high="31" low="28" variants="NVA0-" />
	</reg32>
	
	<array offset="0x0c00" name="VFETCH" stride="0x400" length="1">
		<reg32 offset="0x00" name="JOE" />
		<reg32 offset="0x04" name="TRAP">
			<bitfield name="FAULT" pos="0" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
	</array>

	<reg32 offset="0x1000" name="UNK1000_JOE" />

	<reg32 offset="0x1530" name="UNK1400_JOE" />

	<array offset="0x1800" name="STRMOUT" stride="0x400" length="1">
		<reg32 offset="0x00" name="TRAP">
			<bitfield name="FAULT" pos="0" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x04" name="TRAPPED_STATUS" /> <!-- probably. -->
		<reg32 offset="0x08" name="TRAPPED_ADDRESS_LOW" />
		<reg32 offset="0x0c" name="TRAPPED_ADDRESS_HIGH" />
		<reg32 offset="0x10" name="TRAPPED_DMA" />
		<reg32 offset="0x18" name="JOE" />
	</array>

	<reg32 offset="0x1c04" name="UNK1C00_JOE" />

	<array offset="0x2000" name="CLIPID" stride="0x400" length="1">
		<reg32 offset="0x00" name="TRAP">
			<bitfield name="FAULT" pos="0" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x0c" name="JOE" variants="NVA0-" />
	</array>

	<reg32 offset="0x2404" name="UNK2400_JOE" />

	<reg32 offset="0x2804" name="CSCHED_JOE" />

	<array offset="0x2c00" name="ZCULL" stride="0x400" length="1">
		<reg32 offset="0x18" name="UNK18"/> <!-- mask... -->
		<array offset="0x20" name="REGION" stride="0x10" length="8">
			<reg32 offset="0" name="UNK0" />
			<reg32 offset="4" name="UNK1" />
			<reg32 offset="8" name="UNK2" />
			<reg32 offset="0xc" name="UNK3" />
		</array>
		<reg32 offset="0xbc" name="JOE" />
	</array>

	<reg32 offset="0x3000" name="ENG2D_JOE" />

	<reg32 offset="0x3400" name="UNK3400_JOE" variants="NVA0-" /> <!-- ? -->

	<array offset="0x5000" name="CCACHE" stride="0x400" length="1">
		<array offset="0x04" name="UNK04" stride="8" length="2">
			<reg32 offset="0" name="UNK0" />
			<reg32 offset="4" name="UNK1" />
		</array>
		<reg32 offset="0x18" name="TRAP">
			<bitfield name="FAULT" pos="0" />
			<bitfield name="UNK1" pos="1" />
			<bitfield name="UNK2" pos="2" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x28" name="JOE" /> <!-- a bit... different. -->
	</array>

	<stripe offset="0x6800" name="M2MF">
		<reg32 offset="0x00" name="TRAP">
			<bitfield name="NOTIFY" pos="0" />
			<bitfield name="IN" pos="1" />
			<bitfield name="OUT" pos="2" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x4c" name="OFFSET_IN_0_HIGH" />
		<reg32 offset="0x50" name="OFFSET_IN_0_LOW" />
		<reg32 offset="0x54" name="OFFSET_IN_1_HIGH" />
		<reg32 offset="0x58" name="OFFSET_IN_1_LOW" />

		<reg32 offset="0x88" name="OFFSET_OUT_0_HIGH" />
		<reg32 offset="0x8c" name="OFFSET_OUT_0_LOW" />
		<reg32 offset="0x90" name="OFFSET_OUT_1_HIGH" />
		<reg32 offset="0x94" name="OFFSET_OUT_1_LOW" />
	</stripe>

	<reg32 offset="0x6ff0" name="UNK_CHANINST" length="3">
		<doc>Blob ctxprogs sometimes write current channel's
		instance address >> 12 in here, as well as the following
		two registers. No idea what this is for, our progs don't
		do it and seems like nothing bad happens. Note that NV40
		also has such registers... they're 408000, 408004, 408008
		and store GRCTX instance instead.
		</doc>
	</reg32>

	<array offset="0x7000" name="ROPC" stride="0x100" length="8">
		<!-- one of them is ZROP, the other CROP -->
		<array offset="0" name="UNK1" stride="0x80" length="1">
			<reg32 offset="0x0c" name="JOE" />
			<!-- should be set to the same value as PFB.BANKCFG -->
			<reg32 offset="0x10" name="BANKCFG"/>
		</array>
		<array offset="0x80" name="UNK2" stride="0x80" length="1">
			<reg32 offset="0x10" name="JOE" />
			<reg32 offset="0x14" name="BANKCFG"/>
		</array>
	</array>
	<array offset="0x7c00" name="ROPM" stride="0x200" length="1">
		<array offset="0x7c00" name="ZROP" stride="0x100" length="1">
		</array>
		<array offset="0x7d00" name="CROP" stride="0x100" length="1">
			<reg32 offset="0x00" name="SAMPLECNT"/>
			<reg32 offset="0x20" name="BANKCFG"/>
		</array>
	</array>

	<group name="nv50_pgraph_mp">
		<reg32 offset="0x10" name="PM_CONTROL_3">
			<bitfield name="0" high="7" low="0" />
			<bitfield name="1" high="15" low="8" />
			<bitfield name="2" high="23" low="16" />
			<bitfield name="3" high="31" low="24" />
		</reg32>
		<reg32 offset="0x14" name="ERROR_CODE">
			<bitfield pos="0" name="STACK_UNDERFLOW" />
			<bitfield pos="1" name="STACK_MISMATCH" />
			<bitfield pos="2" name="QUADON_ACTIVE" />
			<bitfield pos="3" name="TIMEOUT" />
			<bitfield pos="4" name="INVALID_OPCODE" />
			<bitfield pos="6" name="BREAKPOINT" />
		</reg32>
		<reg32 offset="0x24" name="PC_CURRENT">
			<bitfield name="ADDR" high="23" low="0" />
			<bitfield name="WARP" high="31" low="24" />
		</reg32>
		<stripe offset="0x38" stride="0x4" length="0x2">
			<reg32 offset="0x0" name="PM_CONTROL_2">
				<bitfield name="0" high="15" low="0" />
				<bitfield name="1" high="31" low="16" />
			</reg32>
		</stripe>
		<!-- 44: Same as 10 or what? -->
		<reg32 offset="0x58" name="CONTROL_0">
			<bitfield name="WATCHDOG" high="20" low="16" />
			<bitfield name="KILL" pos="21" />
			<bitfield name="PM_CONTROL_1_0" high="28" low="26" />
			<bitfield name="PM_CONTROL_1_1" high="31" low="29" />
		</reg32>
		<reg32 offset="0x5c" name="CONTROL_1">
			<bitfield name="PM_CONTROL_1_2" high="2" low="0" />
			<bitfield name="PM_CONTROL_1_3" high="5" low="3" />
			<bitfield name="PM_CONTROL_0_0" pos="14" />
			<bitfield name="PM_CONTROL_0_1" pos="15" />
			<bitfield name="PM_CONTROL_0_2" pos="16" />
			<bitfield name="PM_CONTROL_0_3" pos="17" />
		</reg32>
		<reg32 offset="0x70" name="OPCODE_LOW"/>
		<reg32 offset="0x74" name="OPCODE_HIGH"/>
		<reg32 offset="0x78" name="PC_PREVIOUS">
			<bitfield name="ADDR" high="23" low="0" />
			<bitfield name="WARP" high="31" low="24" />
		</reg32>
	</group>
	<group name="nv50_pgraph_mpc">
		<doc>MP Context. The whole state of MP is accessible indirectly via these registers.
		There are two main areas: small and large. Large contains $r registers and s[]
		space contents. Small contains everything else.
		</doc>
		<reg32 offset="0x3b0" name="MPC_SMALL_SELECT">
			<doc>Selects the 64-bit thing accessible by MPC_SMALL_DATA window.</doc>
			<bitfield high="1" low="0" name="MP">
				<doc>Selects which MP of this TP to access.</doc>
			</bitfield>
			<bitfield high="5" low="2" name="SPACE">
				<doc>Selects which space to access.</doc>
				<value value="0" name="MP_MAIN">
					<doc>Same thing as available directly via PGRAPH_TP_MP.
					Wraps on index 16.</doc>
				</value>
				<value value="1" name="MISC1" />
				<value value="2" name="UNK2"/>
				<value value="3" name="MISC3" />
				<value value="4" name="UNK4"/>
				<value value="5" name="UNK5"/>
				<value value="6" name="UNK6"/>
				<value value="7" name="UNK7"/>
				<value value="9" name="UNK9"/> <!-- code cache? -->
				<value value="0xa" name="UNKA"/>
			</bitfield>
			<bitfield high="31" low="6" name="INDEX">
				<doc>Index inside the selected SPACE to access.
				This bitfield is really smaller, and its usable size
				depends on selected SPACE.</doc>
			</bitfield>
		</reg32>
		<reg64 offset="0x3b4" name="MPC_SMALL_DATA" />
		<reg32 offset="0x3bc" name="MPC_LARGE_SELECT">
			<doc>Selects the 16-word thing accessible by MPC_LARGE_DATA window.</doc>
			<bitfield high="1" low="0" name="MP">
				<doc>Selects which MP of this TP to access.</doc>
			</bitfield>
			<bitfield pos="2" name="SPACE">
				<value value="0" name="REGS">
					<doc>$r registers. These are grouped in 64-reg groups.
					The (warpid, reg index) -> (group, rindex, index)
					mapping can be found in NV50_MPC_SMALL3_LOC0.</doc>
				</value>
				<value value="1" name="SHARED">
					<doc>s[] space, in 64-byte groups.
					(block, offset/64) -> group number mapping can be found
					in NV50_MPC_SMALL3_LOC0.</doc>
				</value>
			</bitfield>
			<bitfield high="4" low="3" name="RINDEX">
				<doc>For registers, selects which subgroup of 16 regs to select
				from the selected 64-reg group. Unused for s[].</doc>
			</bitfield>
			<bitfield high="12" low="5" name="GROUP">
				<doc>Group index to select. Bit 12 is ignored for regs
				on pre-NVA0 cards.</doc>
			</bitfield>
		</reg32>
		<reg32 offset="0x3c0" name="MPC_LARGE_DATA" length="16" />
	</group>

	<group name="nv50_pgraph_tprop">
		<reg32 offset="0x08" name="TPROP_TRAP">
			<bitfield name="SURF_WIDTH_OVERRUN" pos="2" />
			<bitfield name="SURF_HEIGHT_OVERRUN" pos="3" />
			<bitfield name="DST2D_FAULT" pos="4" />
			<bitfield name="ZETA_FAULT" pos="5" />
			<bitfield name="RT_FAULT" pos="6" />
			<bitfield name="CUDA_FAULT" pos="7" />
			<bitfield name="DST2D_STORAGE_TYPE_MISMATCH" pos="8" />
			<bitfield name="ZETA_STORAGE_TYPE_MISMATCH" pos="9" />
			<bitfield name="RT_STORAGE_TYPE_MISMATCH" pos="10" />
			<bitfield name="DST2D_LINEAR_MISMATCH" pos="11" />
			<bitfield name="RT_LINEAR_MISMATCH" pos="12" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x28" name="TPROP_JOE" />
	</group>

	<array offset="0x8000" variants="NV50:NVA0" name="TP" stride="0x1000" length="8">
		<array offset="0x200" name="MP" stride="0x80" length="2">
			<use-group name="nv50_pgraph_mp" />
		</array>
		<reg32 offset="0x310" name="MP_JOE" />
		<reg32 offset="0x314" name="MPC_TRAP">
			<bitfield name="LOCAL_LIMIT_READ" pos="0" />
			<bitfield name="LOCAL_LIMIT_WRITE" pos="4" />
			<bitfield name="STACK_LIMIT" pos="6" />
			<bitfield name="GLOBAL_LIMIT_READ" pos="8" />
			<bitfield name="GLOBAL_LIMIT_WRITE" pos="12" />
			<bitfield name="MP0" pos="16" />
			<bitfield name="MP1" pos="17" />
			<bitfield name="GLOBAL_LIMIT_RED" pos="18" />
			<bitfield name="GLOBAL_LIMIT_ATOM" pos="22" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x414" name="UNK8400_JOE" />
		<reg32 offset="0x824" name="TEXTURE_JOE1" />
		<reg32 offset="0x82c" name="TEXTURE_JOE2" length="8" />
		<reg32 offset="0x900" name="TEXTURE_TRAP">
			<bitfield name="ANY" pos="0" />
			<bitfield name="FAULT" pos="1" />
			<bitfield name="STORAGE_TYPE_MISMATCH" pos="2" />
			<bitfield name="LINEAR_MISMATCH" pos="3" />
			<bitfield name="WRONG_MEMTYPE" pos="5" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0xc04" name="UNK8C00_JOE" />
		<stripe offset="0xe00" stride="0x100" length="1">
			<use-group name="nv50_pgraph_tprop" />
		</stripe>
	</array>

	<array offset="0x8000" variants="NVA0-" name="TP" stride="0x800" length="16">

		<array offset="0x100" name="MP" stride="0x80" length="4">
			<use-group name="nv50_pgraph_mp" />
		</array>
		<reg32 offset="0x31c" name="MPC_TRAP">
			<bitfield name="LOCAL_LIMIT_READ" pos="0" />
			<bitfield name="LOCAL_LIMIT_WRITE" pos="4" />
			<bitfield name="STACK_LIMIT" pos="6" />
			<bitfield name="GLOBAL_LIMIT_READ" pos="8" />
			<bitfield name="GLOBAL_LIMIT_WRITE" pos="12" />
			<bitfield name="MP0" pos="16" />
			<bitfield name="MP1" pos="17" />
			<bitfield name="GLOBAL_LIMIT_RED" pos="18" />
			<bitfield name="GLOBAL_LIMIT_ATOM" pos="22" />
			<bitfield name="MP2" pos="26" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x414" name="UNK8400_JOE" />
		<reg32 offset="0x524" name="TEXTURE_JOE1" />
		<reg32 offset="0x52c" name="TEXTURE_JOE2" length="8" />
		<reg32 offset="0x600" name="TEXTURE_TRAP">
			<bitfield name="ANY" pos="0" />
			<bitfield name="FAULT" pos="1" />
			<bitfield name="STORAGE_TYPE_MISMATCH" pos="2" />
			<bitfield name="LINEAR_MISMATCH" pos="3" />
			<bitfield name="WRONG_MEMTYPE" pos="5" />
			<bitfield name="CLEAR" pos="30" />
			<bitfield name="ENABLE" pos="31" />
		</reg32>
		<reg32 offset="0x084" name="UNK8C00_JOE" />
		<stripe offset="0x700" stride="0x100" length="1">
			<use-group name="nv50_pgraph_tprop" />
		</stripe>
	</array>
</array>
</domain>

<!-- the MP context spaces. -->
<domain name="NV50_MPC_SMALL1" width="64">
	<array offset="0" name="STACK" stride="0x10" length="32">
		<reg64 offset="0" name="ENTRY" length="16">
			<bitfield high="21" low="0" name="PC" shr="2" />
			<!-- 22 and 23 are useless -->
			<bitfield high="28" low="24" name="WARPID" />
			<bitfield high="31" low="29" name="TYPE">
				<value value="1" name="BRANCH" />
				<value value="2" name="CALL1" />
				<value value="3" name="CALL2" />
				<value value="4" name="BREAK" />
				<value value="5" name="QUADON" />
				<value value="6" name="JOINAT" />
			</bitfield>
			<bitfield high="63" low="32" name="LANEMASK"/>
		</reg64>
	</array>
	<reg64 offset="0x200" name="MASK0" length="32">
		<doc>State of each lane. The following combinations are possible:
		<ul>
		<li>M1=0, M2=0: active thread, or merely branched off.</li>
		<li>M1=1, M2=0: thread breaked.</li>
		<li>M1=0, M2=1: thread returned.</li>
		<li>M1=1, M2=1: thread exitted.</li>
		</ul>
		</doc>
		<bitfield high="31" low="0" name="M1" />
		<bitfield high="63" low="32" name="M2" />
	</reg64>
	<reg64 offset="0x220" name="STACK_CONTROL" length="32">
		<bitfield high="12" low="0" name="PTR">
			<doc>Index of current top of the stack entry [ie. last pushed
			entry]. 0x1fff if stack empty.</doc>
		</bitfield>
		<bitfield high="31" low="21" name="UNK"/> <!-- some sort of valid masks... -->
	</reg64>
	<reg64 offset="0x240" name="MASK1" length="32">
		<bitfield high="31" low="0" name="ACTIVE">
			<doc>Mask of active lanes in a warp.</doc>
		</bitfield>
		<bitfield high="63" low="32" name="DEAD">
			<doc>Mask of dead lanes, ie. ones that will
			be skipped by texture insns with "live" flag
			set. For CP, VP, GP set to 1 for unused lanes
			in a warp. For FP, set to 1 for unused lanes
			as well as non-visible pixels that are part
			of visible quad and will be used for computing
			derivatives.</doc>
		</bitfield>
	</reg64>
	<reg64 offset="0x260" name="MASK2" length="32">
		<bitfield high="63" low="32" name="DEAD">
			<doc>Aliases the previous one. nothing to see here.</doc>
		</bitfield>
	</reg64>
	<reg64 offset="0x280" name="PC" shr="2" length="32">
		<doc>The per-warp program counters.</doc>
	</reg64>
	<reg64 offset="0x2a0" name="WARPS">
		<bitfield high="31" low="0" name="ACTIVE">
			<doc>Mask of currently active warps</doc>
		</bitfield>
		<bitfield high="63" low="32" name="SKIPPED">
			<doc>Mask of warps which will be skipped by the CONT command.
			Note that hitting any sort of breakpoint by a warp causes
			the corresponding bit to get set.
			</doc>
		</bitfield>
	</reg64>
	<reg64 offset="0x2a1" name="MISC2">
		<bitfield pos="2" name="SINGLE_STEP">
			<doc>Enables single stepping.</doc>
		</bitfield>
		<bitfield pos="3" name="CONT">
			<doc>Continues paused execution.</doc>
		</bitfield>
		<bitfield pos="4" name="BREAK">
			<doc>Will cause next CUDA execution to start in paused state.</doc>
		</bitfield>
		<bitfield high="63" low="32" name="CRASH_MASK">
			<doc>Mask of warps which blew up</doc>
		</bitfield>
	</reg64>
	<!-- something happens at 0x300+... -->
</domain>
<domain name="NV50_MPC_SMALL2" width="64">
	<array offset="0" name="UNK0" stride="2" length="32">
		<reg64 offset="0" name="SLOT" length="2" />
	</array>
	<array offset="0x40" name="BARRIER_WARP" stride="2" length="32">
		<reg64 offset="0" name="SLOT" length="2">
			<bitfield pos="2" name="UNKALWAYSSET1" />
			<bitfield high="11" low="6" name="UNK2" />
			<bitfield high="29" low="26" name="BARID" />
			<bitfield pos="30" name="INCR" />
			<bitfield pos="31" name="WAIT" />
			<bitfield high="45" low="32" name="UNK46" />
			<bitfield pos="53" name="UNKALWAYSSET2" />
			<bitfield pos="61" name="UNK8" />
		</reg64>
	</array>
	<reg64 offset="0x80" name="UNK2" length="32" />
	<reg64 offset="0xa0" name="UNK3" length="32" />
	<array offset="0xc0" name="UNK4" stride="2" length="32">
		<reg64 offset="0" name="UNK0" />
		<reg64 offset="1" name="UNK1" />
	</array>
	<reg64 offset="0x100" name="BARRIER_COUNTER" length="16">
		<doc>The counters associated with barriers. Inexplicably shifted left by 1 bit. 6-bit on pre-NVA0, most likely 7-bit on NVAx.</doc>
	</reg64>
	<reg64 offset="0x110" name="UNK6" length="8" /> <!-- bits f -->
</domain>
<domain name="NV50_MPC_SMALL3" width="64">
	<reg64 offset="0" name="ADDRESS" length="0x400">
		<doc>$a1-$a4 registers... this shit is so ugly,
		I won't even bother expressing it with proper
		arrays. Basically, register $ax of warp y
		lane z is at bits 16*(z&amp;3)...16*(z&amp;3)+15
		of qword index
		((z&amp;0x10)&gt;&gt;4) + (x-1)*2 + y*8 + ((z&amp;0xc)&gt;&gt;2) * 0x100
		</doc>
	</reg64>
	<reg64 offset="0x400" name="COND" length="0x100">
		<doc>$c0-$c3 registers. Reg $cx of warp y
		lane z is at bits 4*(z&amp;0xf)...4*(z&amp;0xf)+3
		of qword index 
		</doc>
	</reg64>
	<reg64 offset="0x500" name="LOC0" length="0x20">
		<doc>General information about a given warp.</doc>
		<bitfield pos="0" name="REG_PACKED">
			<doc>Use the "packed" format for $r storage.
			If this bit is 0, the "striped" format for $r storage is used.
			Register $rx for thread y in this warp can be find in group
			REG_START + x, at rindex REG_RINDEX + ((y&amp;0x10)>>4),
			in word (y&amp;0xf). Otherwise, the "packed" format for $r
			storage is used, and reg $rx of thread y is stored in group
			REG_GROUP_START + (x>>2) at rindex ((x&amp;3)^(warpid&amp;3)).
			Also, the warps are limitted to 16 threads in this case.</doc>
		</bitfield>
		<bitfield high="3" low="1" name="UNK1" /> <!-- 000 for VP, 001 for GP, 100 for FP, 110 for CP? hm. -->
		<bitfield high="5" low="4" name="REG_RINDEX">
			<doc>The RINDEX to be used for $r regs in this warp, if format is not PACKED.</doc>
		</bitfield>
		<bitfield high="13" low="6" name="REG_START">
			<doc>The starting group number of $r regs in this warp.</doc>
		</bitfield>
		<bitfield high="20" low="14" name="REG_NUM">
			<doc>Number of $r regs in this warp.</doc>
		</bitfield>
		<bitfield high="28" low="21" name="SHARED_START">
			<doc>For CPs, the starting group number of s[] memory of this warp.</doc>
		</bitfield>
		<bitfield high="36" low="29" name="SHARED_LIMIT">
			<doc>For CPs, number of s[] groups - 1.</doc>
		</bitfield>
		<bitfield high="52" low="45" name="BARRIER_START">
		</bitfield>

	</reg64>
	<reg64 offset="0x520" name="LOC1" length="0x20">
		<doc>More general information about a given warp.</doc>
		<!-- 00000000XXXXa0a0 for FPs, 0 for VPs, ??? for CPs, ??? for GPs? hm. -->
	</reg64>
	<reg64 offset="0x540" name="A7" length="0x20"> <!-- aiii! has something in low 32-bit -->
		<doc>$a7 register. Yes, it's per-warp. And it's CP-only.
		Don't ask me why. At least no insane reordering
		is involved.</doc>
		<bitfield high="47" low="32" name="A7" />
	</reg64>
</domain>

</database>
